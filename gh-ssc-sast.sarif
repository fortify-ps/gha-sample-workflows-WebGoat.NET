{
  "$schema" : "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
  "version" : "2.1.0",
  "runs" : [ {
    "tool" : {
      "driver" : {
        "name" : "Fortify SCA",
        "version" : "20.2.1.0010",
        "rules" : [ {
          "id" : "8016",
          "shortDescription" : {
            "text" : "Password Management: Hardcoded Password"
          },
          "fullDescription" : {
            "text" : "Hardcoded passwords can compromise system security in a way that is not easy to remedy.\n\n\n"
          },
          "help" : {
            "text" : "It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. After the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system must choose between security and availability.\n\nExample: The following code uses a hardcoded password to create a network credential:\n\n\n...\nNetworkCredential netCred =\n           new NetworkCredential(\"scott\", \"tiger\", domain);\n...\n\n\nThis code will run successfully, but anyone who has access to it will have access to the password. After the program ships, there is likely no way to change the network credential user \"scott\" with a password of \"tiger\" unless the program is patched. An employee with access to this information can use it to break into the system. If attackers have access to the executable for the application they can disassemble the code, which will contain the values of the passwords used.\n\nPasswords should never be hardcoded and should generally be obfuscated and managed in an external source. Storing passwords in plain text anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password.\n\nMicrosoft(R) provides a tool that can be used in conjunction with the Windows Data Protection application programming interface (DPAPI) to protect sensitive application entries in configuration files [1].\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8016/?engineType=SCA&issue=765A9EC55F4E0B007AE936CF5FA7005D"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8212",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method Page_Load() in addnewuser.aspx.cs mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system or network.\n\nIn this case, the data is passed to set_Text() in addnewuser.aspx.cs at line 22.\n\nExample 1: The following code contains a logging statement that tracks the records added to a database by storing the contents in a log file.\n\n\npass = GetPassword();\n...\ndbmsLog.WriteLine(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in Example 1 logs a plain text password to the file system. Although many developers trust the file system as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern.\n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private.\n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can create risk.\n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer email addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency.\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8212/?engineType=SCA&issue=C7946A05F164FB0C48650D9A10DFDCD1"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "8267",
          "shortDescription" : {
            "text" : "Cookie Security: Cookie not Sent Over SSL"
          },
          "fullDescription" : {
            "text" : "The method Page_Load() in default.aspx.cs on line 29creates a cookie without the <code>secure</code> flag set to <code>true</code>.\n\n\n"
          },
          "help" : {
            "text" : "Modern web browsers support a secure flag for each cookie. If the flag is set, the browser will only send the cookie over HTTPS. Sending cookies over an unencrypted channel can expose them to network sniffing attacks, so the secure flag helps keep a cookie's value confidential. This is especially important if the cookie contains private data or carries a session identifier.\n\n\nIn this case, a cookie is created in default.aspx.cs at line 28, but setSecure() is not called or is called with the value false.\n\n\nExample: In the following example, a cookie is added to the response without setting the Secure property.\n\n...\n HttpCookie cookie = new HttpCookie(\"emailCookie\", email);\n    Response.AppendCookie(cookie);\n...\n\n\nIf your application uses both HTTPS and HTTP but does not set the secure flag, cookies sent during an HTTPS request will also be sent during subsequent HTTP requests. Sniffing network traffic over unencrypted wireless connections is a trivial task for attackers, so sending cookies (especially those with session IDs) over HTTP can result in application compromise.\n\nSet the Secure flag on all new cookies in order to instruct browsers not to send these cookies in the clear.\nExample:\n\n...\n HttpCookie cookie = new HttpCookie(\"emailCookie\", email);\n    cookie.Secure = true;\n    Response.AppendCookie(cookie);\n\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8267/?engineType=SCA&issue=DD2CC28E2790954379C4B3A52240DC05"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "8228",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method btnReverse_Click() in proxysetup.aspx.cs sends unvalidated data to a web browser on line 17, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of reflected XSS, the untrusted source is typically a web request, while in the case of persisted (also known as stored) XSS it is typically a database or other back-end data store.\n\n\nIn this case, the data enters at get_Text() in proxysetup.aspx.cs at line 15.\n\n2. The data is included in dynamic content that is sent to a web user without validation.\n\nIn this case, the data is sent at set_Text() in proxysetup.aspx.cs at line 17.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but can also include HTML, Flash or any other type of code that the browser executes. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following ASP.NET Web Form reads an employee ID number from an HTTP request and displays it to the user.\n\n\n&lt;script runat=\"server\"&gt;\n...\nEmployeeID.Text = Login.Text;\n...\n&lt;/script&gt;\n\n\nWhere Login and EmployeeID are form controls defined as follows:\n\n\n&lt;form runat=\"server\"&gt;\n   &lt;asp:TextBox runat=\"server\" id=\"Login\"/&gt;\n   ...\n   &lt;asp:Label runat=\"server\" id=\"EmployeeID\"/&gt;\n&lt;/form&gt;\n\n\n\nExample 2: The following ASP.NET code segment shows the programmatic way to implement Example 1.\n\n\nprotected System.Web.UI.WebControls.TextBox Login;\nprotected System.Web.UI.WebControls.Label EmployeeID;\n...\nEmployeeID.Text = Login.Text;\n\n\n\nThe code in these examples operates correctly if Login contains only standard alphanumeric text. If Login has a value that includes metacharacters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL which causes malicious code to run on their own computer?  The real danger is that an attacker will create the malicious URL, then use email or social engineering tricks in order to lure victims into clicking a link. When the victims click the link, they unwittingly reflect the malicious content through the vulnerable web application and back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 3: The following ASP.NET Web Form queries a database for an employee with a given employee ID and prints the name corresponding with the ID.\n\n\n&lt;script runat=\"server\"&gt;\n...\nstring query = \"select * from emp where id=\" + eid;\nsda = new SqlDataAdapter(query, conn);\nDataTable dt = new DataTable();\nsda.Fill(dt);\nstring name = dt.Rows[0][\"Name\"];\n...\nEmployeeName.Text = name;\n&lt;/script&gt;\n\n\nWhere EmployeeName is a form control defined as follows:\n\n\n&lt;form runat=\"server\"&gt;\n   ...\n   &lt;asp:Label id=\"EmployeeName\" runat=\"server\"&gt;\n   ...\n&lt;/form&gt;\n\n\n\nExample 4: The following ASP.NET code segment is functionally equivalent to Example 3, but implements all of the form elements programmatically.\n\n\nprotected System.Web.UI.WebControls.Label EmployeeName;\n...\nstring query = \"select * from emp where id=\" + eid;\nsda = new SqlDataAdapter(query, conn);\nDataTable dt = new DataTable();\nsda.Fill(dt);\nstring name = dt.Rows[0][\"Name\"];\n...\nEmployeeName.Text = name;\n\n\n\nAs in Example 1 and Example 2, these code examples function correctly when the values of name are well-behaved, but they nothing to prevent exploits if the values are not. Again, these can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker may execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1 and Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or emailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 3 and Example 4, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\n\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks are made for the correct properties.\n\nBecause XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application might accept input through a shared data store or other trusted source, and that data store might accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means that the best way to prevent XSS vulnerabilities is to validate everything that enters the application and leaves the application destined for the user.\n\nThe most secure approach to validation for XSS is to create an allow list of safe characters that are permitted to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alphanumeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser must be considered valid input after they are encoded, such as a web design bulletin board that must accept HTML fragments from its users.\n\nA more flexible, but less secure approach is to implement a deny list, which selectively rejects or escapes potentially dangerous characters before using the input. To form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and might treat other characters as special in certain contexts, which is why we do not encourage the use of deny lists as a means to prevent XSS. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity.\n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything greater than 127 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- Semicolons, parentheses, curly braces, and new line characters should be filtered out in situations where text could be inserted directly into a pre-existing script tag.\n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering.\n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and might bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nAfter you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and might be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8228/?engineType=SCA&issue=CB9A7AE96C6472D4B07B83FFF6A30AFD"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "7845",
          "shortDescription" : {
            "text" : "Value Shadowing"
          },
          "fullDescription" : {
            "text" : "The function ProcessRequest() in autocomplete.ashx.cs accesses a variable in an ambiguous way at line 25, which can leave the program open to attack.\n\n\n"
          },
          "help" : {
            "text" : "The HttpRequest class provides programmatic access to variables from the QueryString, Form, Cookies or ServerVariables collections in the form of an array access (e.g. Request[\"myParam\"]). When more than one variable exists with the same name, the .NET framework returns the value of the variable that appears first when the collections are searched in the following order: QueryString, Form, Cookies then ServerVariables. Since QueryString comes first in the search order, it is possible for QueryString parameters to supersede values from forms, cookies, and server variables. Similarly, form values can supersede variables in the Cookies and ServerVariables collections and variables from the Cookies collection can supersede those from ServerVariables.\n\nIn this case, the value of a variable accessed from an HttpRequest object at line 25 in autocomplete.ashx.cs can be superseded by an attacker.\n\nExample 1: Imagine a banking application temporarily stores a user's email address in a cookie and reads this value when it wants to contact the user. The following code reads the cookie value and sends an account balance to the specified email address.\n\n...\n    String toAddress = Request[\"email\"];        //Expects cookie value\n    Double balance = GetBalance(userID);\n    SendAccountBalance(toAddress, balance);\n...\n\nAssume the code in Example 1 is executed when visiting http://www.example.com/GetBalance.aspx. If an attacker can cause an authenticated user to click a link that requests http://www.example.com/GetBalance.aspx?email=evil%40evil.com, an email with the user's account balance will be sent to evil@evil.com.\n\nDo not make use of the .NET convenience mechanism for searching multiple collections through an HttpRequest object. Instead, read values directly from the relevant collection or implement your own explicit search order in situations where the desired value might be found in multiple collections.\n\nExample 2: The following code implements the same functionality as Example 1, but instead of accessing the user's email address through the Request object, it accesses the Cookies collection explicitly.\n\n...\n    String toAddress = Request.Cookies[\"email\"];\n    Double balance = GetBalance(userID);\n    SendAccountBalance(toAddress, balance);\n...\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/7845/?engineType=SCA&issue=38A66466156F0EB0331998A43A494035"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8313",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method ProcessRequest() in autocomplete.ashx.cs sends unvalidated data to a web browser on line 33, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of reflected XSS, the untrusted source is typically a web request, while in the case of persisted (also known as stored) XSS it is typically a database or other back-end data store.\n\n\nIn this case, the data enters at get_Item() in autocomplete.ashx.cs at line 25.\n\n2. The data is included in dynamic content that is sent to a web user without validation.\n\nIn this case, the data is sent at Write() in autocomplete.ashx.cs at line 33.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but can also include HTML, Flash or any other type of code that the browser executes. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following ASP.NET Web Form reads an employee ID number from an HTTP request and displays it to the user.\n\n\n&lt;%= Request.Form[\"Login\"] %&gt;\n\n\n\nExample 2: The following ASP.NET code segment shows the programmatic way to implement Example 1.\n\n\nstring ID = Request.Form[\"Login\"];\nResponse.Write(ID);\n\n\n\nThe code in these examples operates correctly if Login contains only standard alphanumeric text. If Login has a value that includes metacharacters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL which causes malicious code to run on their own computer?  The real danger is that an attacker will create the malicious URL, then use email or social engineering tricks in order to lure victims into clicking a link. When the victims click the link, they unwittingly reflect the malicious content through the vulnerable web application and back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 3: The following ASP.NET Web Form queries a database for an employee with a given employee ID and prints the name corresponding with the ID.\n\n\n&lt;%\nstring query = \"select * from emp where id=\" + eid;\nsda = new SqlDataAdapter(query, conn);\nDataTable dt = new DataTable();\nsda.Fill(dt);\nstring name = dt.Rows[0][\"Name\"];\n%&gt;\n...\nEmployee Name: &lt;%= name %&gt;\n\n\n\nExample 4: The following ASP.NET code segment is functionally equivalent to Example 3, but implements all of the form elements programmatically.\n\n\nstring query = \"select * from emp where id=\" + eid;\nsda = new SqlDataAdapter(query, conn);\nDataTable dt = new DataTable();\nsda.Fill(dt);\nstring name = dt.Rows[0][\"Name\"];\n...\nResponse.Write(\"Employee Name: \" + name);\n\n\n\nAs in Example 1 and Example 2, these code examples function correctly when the values of name are well-behaved, but they nothing to prevent exploits if the values are not. Again, these can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker may execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1 and Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or emailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 3 and Example 4, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\n\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks are made for the correct properties.\n\nBecause XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application might accept input through a shared data store or other trusted source, and that data store might accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means that the best way to prevent XSS vulnerabilities is to validate everything that enters the application and leaves the application destined for the user.\n\nThe most secure approach to validation for XSS is to create an allow list of safe characters that are permitted to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alphanumeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser must be considered valid input after they are encoded, such as a web design bulletin board that must accept HTML fragments from its users.\n\nA more flexible, but less secure approach is to implement a deny list, which selectively rejects or escapes potentially dangerous characters before using the input. To form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and might treat other characters as special in certain contexts, which is why we do not encourage the use of deny lists as a means to prevent XSS. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity.\n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything greater than 127 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- Semicolons, parentheses, curly braces, and new line characters should be filtered out in situations where text could be inserted directly into a pre-existing script tag.\n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering.\n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and might bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nAfter you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and might be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8313/?engineType=SCA&issue=F374EA20FC310E7762297E5FFE4D7B65"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "7902",
          "shortDescription" : {
            "text" : "Log Forging"
          },
          "fullDescription" : {
            "text" : "The method ButtonLogOn_Click() in customerlogin.aspx.cs writes unvalidated user input to the log on line 36. An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.\n\n\n"
          },
          "help" : {
            "text" : "Log forging vulnerabilities occur when:\n\n1.Data enters an application from an untrusted source.\n\nIn this case, the data enters at get_Text() in customerlogin.aspx.cs at line 34.\n\n2.The data is written to an application or system log file.\n\nIn this case, the data is logged by Info() in customerlogin.aspx.cs at line 36.\n\nApplications typically use log files to store a history of events or transactions for later review, statistics gathering, or debugging. Depending on the nature of the application, the task of reviewing log files may be performed manually on an as-needed basis or automated with a tool that automatically culls logs for important events or trending information.\n\nInterpretation of the log files may be hindered or misdirected if an attacker can supply data to the application that is subsequently logged verbatim. In the most benign case, an attacker may be able to insert false entries into the log file by providing the application with input that includes appropriate characters. If the log file is processed automatically, the attacker may be able to render the file unusable by corrupting the format of the file or injecting unexpected characters. A more subtle attack might involve skewing the log file statistics. Forged or otherwise, corrupted log files can be used to cover an attacker's tracks or even to implicate another party in the commission of a malicious act [1]. In the worst case, an attacker may inject code or other commands into the log file and take advantage of a vulnerability in the log processing utility [2].\n\nExample: The following web application code attempts to read an integer value from a request object. If the value fails to parse as an integer, then the input is logged with an error message indicating what happened.\n\n\n...\nstring val = (string)Session[\"val\"];\ntry {\nint value = Int32.Parse(val);\n}\ncatch (FormatException fe) {\nlog.Info(\"Failed to parse val= \" + val);\n}\n...\n\n\nIf a user submits the string \"twenty-one\" for val, the following entry is logged:\n\n\nINFO: Failed to parse val=twenty-one\n\n\nHowever, if an attacker submits the string \"twenty-one%0a%0aINFO:+User+logged+out%3dbadguy\", the following entry is logged:\n\n\nINFO: Failed to parse val=twenty-one\n\nINFO: User logged out=badguy\n\n\nClearly, attackers may use this same mechanism to insert arbitrary log entries.\n\nPrevent log forging attacks with indirection: create a set of legitimate log entries that correspond to different events that must be logged and only log entries from this set. To capture dynamic content, such as users logging out of the system, always use server-controlled values rather than user-supplied data. This ensures that the input provided by the user is never used directly in a log entry.\n\nIn some situations this approach is impractical because the set of legitimate log entries is too large or complicated. In these situations, developers often fall back on implementing a deny list. A deny list is used to selectively reject or escape potentially dangerous characters before using the input. However, a list of unsafe characters can quickly become incomplete or outdated. A better approach is to create a list of characters that are permitted to appear in log entries and accept input composed exclusively of characters in the approved set. The most critical character in most log forging attacks is the '\n' (newline) character, which should never appear on a log entry allow list.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/7902/?engineType=SCA&issue=48F1D62602B44E56380F09336982B2A0"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "7936",
          "shortDescription" : {
            "text" : "Log Forging"
          },
          "fullDescription" : {
            "text" : "The method ButtonLogOn_Click() in customerlogin.aspx.cs writes unvalidated user input to the log on line 36. An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.\n\n\n"
          },
          "help" : {
            "text" : "Log forging vulnerabilities occur when:\n\n1.Data enters an application from an untrusted source.\n\nIn this case, the data enters at get_Text() in customerlogin.aspx.cs at line 33.\n\n2.The data is written to an application or system log file.\n\nIn this case, the data is logged by Info() in customerlogin.aspx.cs at line 36.\n\nApplications typically use log files to store a history of events or transactions for later review, statistics gathering, or debugging. Depending on the nature of the application, the task of reviewing log files may be performed manually on an as-needed basis or automated with a tool that automatically culls logs for important events or trending information.\n\nInterpretation of the log files may be hindered or misdirected if an attacker can supply data to the application that is subsequently logged verbatim. In the most benign case, an attacker may be able to insert false entries into the log file by providing the application with input that includes appropriate characters. If the log file is processed automatically, the attacker may be able to render the file unusable by corrupting the format of the file or injecting unexpected characters. A more subtle attack might involve skewing the log file statistics. Forged or otherwise, corrupted log files can be used to cover an attacker's tracks or even to implicate another party in the commission of a malicious act [1]. In the worst case, an attacker may inject code or other commands into the log file and take advantage of a vulnerability in the log processing utility [2].\n\nExample: The following web application code attempts to read an integer value from a request object. If the value fails to parse as an integer, then the input is logged with an error message indicating what happened.\n\n\n...\nstring val = (string)Session[\"val\"];\ntry {\nint value = Int32.Parse(val);\n}\ncatch (FormatException fe) {\nlog.Info(\"Failed to parse val= \" + val);\n}\n...\n\n\nIf a user submits the string \"twenty-one\" for val, the following entry is logged:\n\n\nINFO: Failed to parse val=twenty-one\n\n\nHowever, if an attacker submits the string \"twenty-one%0a%0aINFO:+User+logged+out%3dbadguy\", the following entry is logged:\n\n\nINFO: Failed to parse val=twenty-one\n\nINFO: User logged out=badguy\n\n\nClearly, attackers may use this same mechanism to insert arbitrary log entries.\n\nPrevent log forging attacks with indirection: create a set of legitimate log entries that correspond to different events that must be logged and only log entries from this set. To capture dynamic content, such as users logging out of the system, always use server-controlled values rather than user-supplied data. This ensures that the input provided by the user is never used directly in a log entry.\n\nIn some situations this approach is impractical because the set of legitimate log entries is too large or complicated. In these situations, developers often fall back on implementing a deny list. A deny list is used to selectively reject or escape potentially dangerous characters before using the input. However, a list of unsafe characters can quickly become incomplete or outdated. A better approach is to create a list of characters that are permitted to appear in log entries and accept input composed exclusively of characters in the approved set. The most critical character in most log forging attacks is the '\n' (newline) character, which should never appear on a log entry allow list.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/7936/?engineType=SCA&issue=576C98CD06F4BCB300512F3FD89466E8"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "7888",
          "shortDescription" : {
            "text" : "Cookie Security: Cookie not Sent Over SSL"
          },
          "fullDescription" : {
            "text" : "The method ButtonLogOn_Click() in customerlogin.aspx.cs on line 65creates a cookie without the <code>secure</code> flag set to <code>true</code>.\n\n\n"
          },
          "help" : {
            "text" : "Modern web browsers support a secure flag for each cookie. If the flag is set, the browser will only send the cookie over HTTPS. Sending cookies over an unencrypted channel can expose them to network sniffing attacks, so the secure flag helps keep a cookie's value confidential. This is especially important if the cookie contains private data or carries a session identifier.\n\n\nIn this case, a cookie is created in customerlogin.aspx.cs at line 59, but setSecure() is not called or is called with the value false.\n\n\nExample: In the following example, a cookie is added to the response without setting the Secure property.\n\n...\n HttpCookie cookie = new HttpCookie(\"emailCookie\", email);\n    Response.AppendCookie(cookie);\n...\n\n\nIf your application uses both HTTPS and HTTP but does not set the secure flag, cookies sent during an HTTPS request will also be sent during subsequent HTTP requests. Sniffing network traffic over unencrypted wireless connections is a trivial task for attackers, so sending cookies (especially those with session IDs) over HTTP can result in application compromise.\n\nSet the Secure flag on all new cookies in order to instruct browsers not to send these cookies in the clear.\nExample:\n\n...\n HttpCookie cookie = new HttpCookie(\"emailCookie\", email);\n    cookie.Secure = true;\n    Response.AppendCookie(cookie);\n\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/7888/?engineType=SCA&issue=45B5287CA14A1063A52C820B8C8E0829"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "8284",
          "shortDescription" : {
            "text" : "Open Redirect"
          },
          "fullDescription" : {
            "text" : "The file customerlogin.aspx.cs passes unvalidated data to an HTTP redirect on line 72. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.\n\n\n"
          },
          "help" : {
            "text" : "Redirects allow web applications to direct users to different pages within the same application or to external sites. Applications utilize redirects to aid in site navigation and, in some cases, to track how users exit the site. Open redirect vulnerabilities occur when a web application redirects clients to any arbitrary URL that can be controlled by an attacker.\n\nAttackers may utilize open redirects to trick users into visiting a URL to a trusted site and redirecting them to a malicious site. By encoding the URL, an attacker is able to make it more difficult for end-users to notice the malicious destination of the redirect, even when it is passed as a URL parameter to the trusted site. Open redirects are often abused as part of phishing scams to harvest sensitive end-user data.\n\n\nIn this case, the URL the client will be redirected to is accepted at get_QueryString() in customerlogin.aspx.cs at line 67.\n\nThe data is sent at Redirect() in customerlogin.aspx.cs at line 72.\n\n\nExample 1: The following code instructs the user's browser to open a URL parsed from the dest request parameter when a user clicks the link.\n\n\n    String redirect = Request[\"dest\"];\n    Response.Redirect(redirect);\n\n\nIf a victim receives an email instructing them to follow a link to \"http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com\", the user might click on the link believing they would be transferred to the trusted site. However, when the victim clicks the link, the code in Example 1 will redirect the browser to \"http://www.wilyhacker.com\".\n\nMany users have been educated to always inspect URLs they receive in emails to make sure the link specifies a trusted site they know. However, if the attacker encoded the destination url as follows:\n\"http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D\"\n\nthen even a savvy end-user may be fooled into following the link.\n\nUnvalidated user input should not be allowed to control the destination URL in a redirect. Instead, use a level of indirection: create a list of legitimate URLs that users are allowed to specify and only allow users to select from the list. With this approach, input provided by users is never used directly to specify a URL for redirects.\n\nExample 2: The following code references an array populated with valid URLs. The link the user clicks passes in the array index that corresponds to the desired URL.\n\n\n    String redirect = Request[\"dest\"];\n    Int32 strDest = System.Convert.ToInt32(redirect);\n    if((strDest &gt;= 0) &amp;&amp; (strDest &lt;= strURLArray.Length -1 ))\n    {\n        strFinalURL = strURLArray[strDest];\n        pageContext.forward(strFinalURL);\n    }\n\n\nIn some situations this approach is impractical because the set of legitimate URLs is too large or too hard to keep track of. In such cases, use a similar approach to restrict the domains that users can be redirected to, which can at least prevent attackers from sending users to malicious external sites.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8284/?engineType=SCA&issue=E3ED55F907777B9A8403F632AEACC416"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "8151",
          "shortDescription" : {
            "text" : "Cookie Security: Cookie not Sent Over SSL"
          },
          "fullDescription" : {
            "text" : "The method ButtonCheckEmail_Click() in forgotpassword.aspx.cs on line 49creates a cookie without the <code>secure</code> flag set to <code>true</code>.\n\n\n"
          },
          "help" : {
            "text" : "Modern web browsers support a secure flag for each cookie. If the flag is set, the browser will only send the cookie over HTTPS. Sending cookies over an unencrypted channel can expose them to network sniffing attacks, so the secure flag helps keep a cookie's value confidential. This is especially important if the cookie contains private data or carries a session identifier.\n\n\nIn this case, a cookie is created in forgotpassword.aspx.cs at line 43, but setSecure() is not called or is called with the value false.\n\n\nExample: In the following example, a cookie is added to the response without setting the Secure property.\n\n...\n HttpCookie cookie = new HttpCookie(\"emailCookie\", email);\n    Response.AppendCookie(cookie);\n...\n\n\nIf your application uses both HTTPS and HTTP but does not set the secure flag, cookies sent during an HTTPS request will also be sent during subsequent HTTP requests. Sniffing network traffic over unencrypted wireless connections is a trivial task for attackers, so sending cookies (especially those with session IDs) over HTTP can result in application compromise.\n\nSet the Secure flag on all new cookies in order to instruct browsers not to send these cookies in the clear.\nExample:\n\n...\n HttpCookie cookie = new HttpCookie(\"emailCookie\", email);\n    cookie.Secure = true;\n    Response.AppendCookie(cookie);\n\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8151/?engineType=SCA&issue=B0F9B4482C54466AA26A214B09177364"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "7709",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method ButtonRecoverPassword_Click() in forgotpassword.aspx.cs mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system or network.\n\nIn this case, the data is passed to set_Text() in forgotpassword.aspx.cs at line 67.\n\nExample 1: The following code contains a logging statement that tracks the records added to a database by storing the contents in a log file.\n\n\npass = GetPassword();\n...\ndbmsLog.WriteLine(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in Example 1 logs a plain text password to the file system. Although many developers trust the file system as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern.\n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private.\n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can create risk.\n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer email addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency.\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/7709/?engineType=SCA&issue=03BC7868161DEF7D124EBC88C1921287"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "8018",
          "shortDescription" : {
            "text" : "Value Shadowing"
          },
          "fullDescription" : {
            "text" : "The function Page_Load() in orders.aspx.cs accesses a variable in an ambiguous way at line 62, which can leave the program open to attack.\n\n\n"
          },
          "help" : {
            "text" : "The HttpRequest class provides programmatic access to variables from the QueryString, Form, Cookies or ServerVariables collections in the form of an array access (e.g. Request[\"myParam\"]). When more than one variable exists with the same name, the .NET framework returns the value of the variable that appears first when the collections are searched in the following order: QueryString, Form, Cookies then ServerVariables. Since QueryString comes first in the search order, it is possible for QueryString parameters to supersede values from forms, cookies, and server variables. Similarly, form values can supersede variables in the Cookies and ServerVariables collections and variables from the Cookies collection can supersede those from ServerVariables.\n\nIn this case, the value of a variable accessed from an HttpRequest object at line 62 in orders.aspx.cs can be superseded by an attacker.\n\nExample 1: Imagine a banking application temporarily stores a user's email address in a cookie and reads this value when it wants to contact the user. The following code reads the cookie value and sends an account balance to the specified email address.\n\n...\n    String toAddress = Request[\"email\"];        //Expects cookie value\n    Double balance = GetBalance(userID);\n    SendAccountBalance(toAddress, balance);\n...\n\nAssume the code in Example 1 is executed when visiting http://www.example.com/GetBalance.aspx. If an attacker can cause an authenticated user to click a link that requests http://www.example.com/GetBalance.aspx?email=evil%40evil.com, an email with the user's account balance will be sent to evil@evil.com.\n\nDo not make use of the .NET convenience mechanism for searching multiple collections through an HttpRequest object. Instead, read values directly from the relevant collection or implement your own explicit search order in situations where the desired value might be found in multiple collections.\n\nExample 2: The following code implements the same functionality as Example 1, but instead of accessing the user's email address through the Request object, it accesses the Cookies collection explicitly.\n\n...\n    String toAddress = Request.Cookies[\"email\"];\n    Double balance = GetBalance(userID);\n    SendAccountBalance(toAddress, balance);\n...\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8018/?engineType=SCA&issue=76D9ABB086936612CCC216B575F9BD65"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8146",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method Page_Load() in orders.aspx.cs sends unvalidated data to a web browser on line 77, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of reflected XSS, the untrusted source is typically a web request, while in the case of persisted (also known as stored) XSS it is typically a database or other back-end data store.\n\n\nIn this case, the data enters at get_RawUrl() in orders.aspx.cs at line 77.\n\n2. The data is included in dynamic content that is sent to a web user without validation.\n\nIn this case, the data is sent at set_NavigateUrl() in orders.aspx.cs at line 77.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but can also include HTML, Flash or any other type of code that the browser executes. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following ASP.NET Web Form reads an employee ID number from an HTTP request and displays it to the user.\n\n\n&lt;script runat=\"server\"&gt;\n...\nEmployeeID.Text = Login.Text;\n...\n&lt;/script&gt;\n\n\nWhere Login and EmployeeID are form controls defined as follows:\n\n\n&lt;form runat=\"server\"&gt;\n   &lt;asp:TextBox runat=\"server\" id=\"Login\"/&gt;\n   ...\n   &lt;asp:Label runat=\"server\" id=\"EmployeeID\"/&gt;\n&lt;/form&gt;\n\n\n\nExample 2: The following ASP.NET code segment shows the programmatic way to implement Example 1.\n\n\nprotected System.Web.UI.WebControls.TextBox Login;\nprotected System.Web.UI.WebControls.Label EmployeeID;\n...\nEmployeeID.Text = Login.Text;\n\n\n\nThe code in these examples operates correctly if Login contains only standard alphanumeric text. If Login has a value that includes metacharacters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL which causes malicious code to run on their own computer?  The real danger is that an attacker will create the malicious URL, then use email or social engineering tricks in order to lure victims into clicking a link. When the victims click the link, they unwittingly reflect the malicious content through the vulnerable web application and back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 3: The following ASP.NET Web Form queries a database for an employee with a given employee ID and prints the name corresponding with the ID.\n\n\n&lt;script runat=\"server\"&gt;\n...\nstring query = \"select * from emp where id=\" + eid;\nsda = new SqlDataAdapter(query, conn);\nDataTable dt = new DataTable();\nsda.Fill(dt);\nstring name = dt.Rows[0][\"Name\"];\n...\nEmployeeName.Text = name;\n&lt;/script&gt;\n\n\nWhere EmployeeName is a form control defined as follows:\n\n\n&lt;form runat=\"server\"&gt;\n   ...\n   &lt;asp:Label id=\"EmployeeName\" runat=\"server\"&gt;\n   ...\n&lt;/form&gt;\n\n\n\nExample 4: The following ASP.NET code segment is functionally equivalent to Example 3, but implements all of the form elements programmatically.\n\n\nprotected System.Web.UI.WebControls.Label EmployeeName;\n...\nstring query = \"select * from emp where id=\" + eid;\nsda = new SqlDataAdapter(query, conn);\nDataTable dt = new DataTable();\nsda.Fill(dt);\nstring name = dt.Rows[0][\"Name\"];\n...\nEmployeeName.Text = name;\n\n\n\nAs in Example 1 and Example 2, these code examples function correctly when the values of name are well-behaved, but they nothing to prevent exploits if the values are not. Again, these can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker may execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1 and Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or emailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 3 and Example 4, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\n\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks are made for the correct properties.\n\nBecause XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application might accept input through a shared data store or other trusted source, and that data store might accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means that the best way to prevent XSS vulnerabilities is to validate everything that enters the application and leaves the application destined for the user.\n\nThe most secure approach to validation for XSS is to create an allow list of safe characters that are permitted to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alphanumeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser must be considered valid input after they are encoded, such as a web design bulletin board that must accept HTML fragments from its users.\n\nA more flexible, but less secure approach is to implement a deny list, which selectively rejects or escapes potentially dangerous characters before using the input. To form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and might treat other characters as special in certain contexts, which is why we do not encourage the use of deny lists as a means to prevent XSS. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity.\n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything greater than 127 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- Semicolons, parentheses, curly braces, and new line characters should be filtered out in situations where text could be inserted directly into a pre-existing script tag.\n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering.\n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and might bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nAfter you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and might be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8146/?engineType=SCA&issue=ADB3FC4234A79F01B0CDAFF8A305CCCB"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "7804",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method Page_Load() in orders.aspx.cs sends unvalidated data to a web browser on line 83, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of reflected XSS, the untrusted source is typically a web request, while in the case of persisted (also known as stored) XSS it is typically a database or other back-end data store.\n\n\nIn this case, the data enters at get_Item() in orders.aspx.cs at line 62.\n\n2. The data is included in dynamic content that is sent to a web user without validation.\n\nIn this case, the data is sent at set_Text() in orders.aspx.cs at line 83.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but can also include HTML, Flash or any other type of code that the browser executes. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following ASP.NET Web Form reads an employee ID number from an HTTP request and displays it to the user.\n\n\n&lt;script runat=\"server\"&gt;\n...\nEmployeeID.Text = Login.Text;\n...\n&lt;/script&gt;\n\n\nWhere Login and EmployeeID are form controls defined as follows:\n\n\n&lt;form runat=\"server\"&gt;\n   &lt;asp:TextBox runat=\"server\" id=\"Login\"/&gt;\n   ...\n   &lt;asp:Label runat=\"server\" id=\"EmployeeID\"/&gt;\n&lt;/form&gt;\n\n\n\nExample 2: The following ASP.NET code segment shows the programmatic way to implement Example 1.\n\n\nprotected System.Web.UI.WebControls.TextBox Login;\nprotected System.Web.UI.WebControls.Label EmployeeID;\n...\nEmployeeID.Text = Login.Text;\n\n\n\nThe code in these examples operates correctly if Login contains only standard alphanumeric text. If Login has a value that includes metacharacters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL which causes malicious code to run on their own computer?  The real danger is that an attacker will create the malicious URL, then use email or social engineering tricks in order to lure victims into clicking a link. When the victims click the link, they unwittingly reflect the malicious content through the vulnerable web application and back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 3: The following ASP.NET Web Form queries a database for an employee with a given employee ID and prints the name corresponding with the ID.\n\n\n&lt;script runat=\"server\"&gt;\n...\nstring query = \"select * from emp where id=\" + eid;\nsda = new SqlDataAdapter(query, conn);\nDataTable dt = new DataTable();\nsda.Fill(dt);\nstring name = dt.Rows[0][\"Name\"];\n...\nEmployeeName.Text = name;\n&lt;/script&gt;\n\n\nWhere EmployeeName is a form control defined as follows:\n\n\n&lt;form runat=\"server\"&gt;\n   ...\n   &lt;asp:Label id=\"EmployeeName\" runat=\"server\"&gt;\n   ...\n&lt;/form&gt;\n\n\n\nExample 4: The following ASP.NET code segment is functionally equivalent to Example 3, but implements all of the form elements programmatically.\n\n\nprotected System.Web.UI.WebControls.Label EmployeeName;\n...\nstring query = \"select * from emp where id=\" + eid;\nsda = new SqlDataAdapter(query, conn);\nDataTable dt = new DataTable();\nsda.Fill(dt);\nstring name = dt.Rows[0][\"Name\"];\n...\nEmployeeName.Text = name;\n\n\n\nAs in Example 1 and Example 2, these code examples function correctly when the values of name are well-behaved, but they nothing to prevent exploits if the values are not. Again, these can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker may execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1 and Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or emailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 3 and Example 4, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\n\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks are made for the correct properties.\n\nBecause XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application might accept input through a shared data store or other trusted source, and that data store might accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means that the best way to prevent XSS vulnerabilities is to validate everything that enters the application and leaves the application destined for the user.\n\nThe most secure approach to validation for XSS is to create an allow list of safe characters that are permitted to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alphanumeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser must be considered valid input after they are encoded, such as a web design bulletin board that must accept HTML fragments from its users.\n\nA more flexible, but less secure approach is to implement a deny list, which selectively rejects or escapes potentially dangerous characters before using the input. To form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and might treat other characters as special in certain contexts, which is why we do not encourage the use of deny lists as a means to prevent XSS. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity.\n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything greater than 127 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- Semicolons, parentheses, curly braces, and new line characters should be filtered out in situations where text could be inserted directly into a pre-existing script tag.\n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering.\n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and might bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nAfter you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and might be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/7804/?engineType=SCA&issue=2C3E7E16EDD57F1174C139FC41B0E86F"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8337",
          "shortDescription" : {
            "text" : "Value Shadowing"
          },
          "fullDescription" : {
            "text" : "The function Page_Load() in orders.aspx.cs accesses a variable in an ambiguous way at line 88, which can leave the program open to attack.\n\n\n"
          },
          "help" : {
            "text" : "The HttpRequest class provides programmatic access to variables from the QueryString, Form, Cookies or ServerVariables collections in the form of an array access (e.g. Request[\"myParam\"]). When more than one variable exists with the same name, the .NET framework returns the value of the variable that appears first when the collections are searched in the following order: QueryString, Form, Cookies then ServerVariables. Since QueryString comes first in the search order, it is possible for QueryString parameters to supersede values from forms, cookies, and server variables. Similarly, form values can supersede variables in the Cookies and ServerVariables collections and variables from the Cookies collection can supersede those from ServerVariables.\n\nIn this case, the value of a variable accessed from an HttpRequest object at line 88 in orders.aspx.cs can be superseded by an attacker.\n\nExample 1: Imagine a banking application temporarily stores a user's email address in a cookie and reads this value when it wants to contact the user. The following code reads the cookie value and sends an account balance to the specified email address.\n\n...\n    String toAddress = Request[\"email\"];        //Expects cookie value\n    Double balance = GetBalance(userID);\n    SendAccountBalance(toAddress, balance);\n...\n\nAssume the code in Example 1 is executed when visiting http://www.example.com/GetBalance.aspx. If an attacker can cause an authenticated user to click a link that requests http://www.example.com/GetBalance.aspx?email=evil%40evil.com, an email with the user's account balance will be sent to evil@evil.com.\n\nDo not make use of the .NET convenience mechanism for searching multiple collections through an HttpRequest object. Instead, read values directly from the relevant collection or implement your own explicit search order in situations where the desired value might be found in multiple collections.\n\nExample 2: The following code implements the same functionality as Example 1, but instead of accessing the user's email address through the Request object, it accesses the Cookies collection explicitly.\n\n...\n    String toAddress = Request.Cookies[\"email\"];\n    Double balance = GetBalance(userID);\n    SendAccountBalance(toAddress, balance);\n...\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8337/?engineType=SCA&issue=FC48340624DC5715BD6CA816799C7D75"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "7782",
          "shortDescription" : {
            "text" : "Value Shadowing"
          },
          "fullDescription" : {
            "text" : "The function LoadComments() in productdetails.aspx.cs accesses a variable in an ambiguous way at line 55, which can leave the program open to attack.\n\n\n"
          },
          "help" : {
            "text" : "The HttpRequest class provides programmatic access to variables from the QueryString, Form, Cookies or ServerVariables collections in the form of an array access (e.g. Request[\"myParam\"]). When more than one variable exists with the same name, the .NET framework returns the value of the variable that appears first when the collections are searched in the following order: QueryString, Form, Cookies then ServerVariables. Since QueryString comes first in the search order, it is possible for QueryString parameters to supersede values from forms, cookies, and server variables. Similarly, form values can supersede variables in the Cookies and ServerVariables collections and variables from the Cookies collection can supersede those from ServerVariables.\n\nIn this case, the value of a variable accessed from an HttpRequest object at line 55 in productdetails.aspx.cs can be superseded by an attacker.\n\nExample 1: Imagine a banking application temporarily stores a user's email address in a cookie and reads this value when it wants to contact the user. The following code reads the cookie value and sends an account balance to the specified email address.\n\n...\n    String toAddress = Request[\"email\"];        //Expects cookie value\n    Double balance = GetBalance(userID);\n    SendAccountBalance(toAddress, balance);\n...\n\nAssume the code in Example 1 is executed when visiting http://www.example.com/GetBalance.aspx. If an attacker can cause an authenticated user to click a link that requests http://www.example.com/GetBalance.aspx?email=evil%40evil.com, an email with the user's account balance will be sent to evil@evil.com.\n\nDo not make use of the .NET convenience mechanism for searching multiple collections through an HttpRequest object. Instead, read values directly from the relevant collection or implement your own explicit search order in situations where the desired value might be found in multiple collections.\n\nExample 2: The following code implements the same functionality as Example 1, but instead of accessing the user's email address through the Request object, it accesses the Cookies collection explicitly.\n\n...\n    String toAddress = Request.Cookies[\"email\"];\n    Double balance = GetBalance(userID);\n    SendAccountBalance(toAddress, balance);\n...\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/7782/?engineType=SCA&issue=22C287B39C27FBCFAA7CC8CAD32D5129"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8231",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method MakeRow() in encryptvsencode.aspx.cs sends unvalidated data to a web browser on line 67, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of reflected XSS, the untrusted source is typically a web request, while in the case of persisted (also known as stored) XSS it is typically a database or other back-end data store.\n\n\nIn this case, the data enters at get_Text() in encryptvsencode.aspx.cs at line 38.\n\n2. The data is included in dynamic content that is sent to a web user without validation.\n\nIn this case, the data is sent at set_Text() in encryptvsencode.aspx.cs at line 67.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but can also include HTML, Flash or any other type of code that the browser executes. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following ASP.NET Web Form reads an employee ID number from an HTTP request and displays it to the user.\n\n\n&lt;script runat=\"server\"&gt;\n...\nEmployeeID.Text = Login.Text;\n...\n&lt;/script&gt;\n\n\nWhere Login and EmployeeID are form controls defined as follows:\n\n\n&lt;form runat=\"server\"&gt;\n   &lt;asp:TextBox runat=\"server\" id=\"Login\"/&gt;\n   ...\n   &lt;asp:Label runat=\"server\" id=\"EmployeeID\"/&gt;\n&lt;/form&gt;\n\n\n\nExample 2: The following ASP.NET code segment shows the programmatic way to implement Example 1.\n\n\nprotected System.Web.UI.WebControls.TextBox Login;\nprotected System.Web.UI.WebControls.Label EmployeeID;\n...\nEmployeeID.Text = Login.Text;\n\n\n\nThe code in these examples operates correctly if Login contains only standard alphanumeric text. If Login has a value that includes metacharacters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL which causes malicious code to run on their own computer?  The real danger is that an attacker will create the malicious URL, then use email or social engineering tricks in order to lure victims into clicking a link. When the victims click the link, they unwittingly reflect the malicious content through the vulnerable web application and back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 3: The following ASP.NET Web Form queries a database for an employee with a given employee ID and prints the name corresponding with the ID.\n\n\n&lt;script runat=\"server\"&gt;\n...\nstring query = \"select * from emp where id=\" + eid;\nsda = new SqlDataAdapter(query, conn);\nDataTable dt = new DataTable();\nsda.Fill(dt);\nstring name = dt.Rows[0][\"Name\"];\n...\nEmployeeName.Text = name;\n&lt;/script&gt;\n\n\nWhere EmployeeName is a form control defined as follows:\n\n\n&lt;form runat=\"server\"&gt;\n   ...\n   &lt;asp:Label id=\"EmployeeName\" runat=\"server\"&gt;\n   ...\n&lt;/form&gt;\n\n\n\nExample 4: The following ASP.NET code segment is functionally equivalent to Example 3, but implements all of the form elements programmatically.\n\n\nprotected System.Web.UI.WebControls.Label EmployeeName;\n...\nstring query = \"select * from emp where id=\" + eid;\nsda = new SqlDataAdapter(query, conn);\nDataTable dt = new DataTable();\nsda.Fill(dt);\nstring name = dt.Rows[0][\"Name\"];\n...\nEmployeeName.Text = name;\n\n\n\nAs in Example 1 and Example 2, these code examples function correctly when the values of name are well-behaved, but they nothing to prevent exploits if the values are not. Again, these can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker may execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1 and Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or emailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 3 and Example 4, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\n\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks are made for the correct properties.\n\nBecause XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application might accept input through a shared data store or other trusted source, and that data store might accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means that the best way to prevent XSS vulnerabilities is to validate everything that enters the application and leaves the application destined for the user.\n\nThe most secure approach to validation for XSS is to create an allow list of safe characters that are permitted to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alphanumeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser must be considered valid input after they are encoded, such as a web design bulletin board that must accept HTML fragments from its users.\n\nA more flexible, but less secure approach is to implement a deny list, which selectively rejects or escapes potentially dangerous characters before using the input. To form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and might treat other characters as special in certain contexts, which is why we do not encourage the use of deny lists as a means to prevent XSS. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity.\n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything greater than 127 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- Semicolons, parentheses, curly braces, and new line characters should be filtered out in situations where text could be inserted directly into a pre-existing script tag.\n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering.\n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and might bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nAfter you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and might be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8231/?engineType=SCA&issue=CC68CE1FC5C0BDD15408957BCC20B946"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8021",
          "shortDescription" : {
            "text" : "Null Dereference"
          },
          "fullDescription" : {
            "text" : "The method SHA() in encryptvsencode.aspx.cs can dereference a null-pointer on line 108, thereby raising a <code>NullException</code>.\n\n\n"
          },
          "help" : {
            "text" : "Null-pointer errors are usually the result of one or more programmer assumptions being violated.\n\nIn this case, the variable can be null when it is dereferenced at line 108, thereby raising a NullException.\n\nMost null-pointer issues result in general software reliability problems, but if an attacker can intentionally trigger a null-pointer dereference, the attacker may be able to use the resulting exception to bypass security logic or to cause the application to reveal debugging information that will be valuable in planning subsequent attacks.\n\nExample 1: In the following code, the programmer assumes that the system always has a property named \"cmd\" defined. If an attacker can control the program's environment so that \"cmd\" is not defined, the program throws a null-pointer exception when it attempts to call the Trim() method.\n\n\nstring cmd = null;\n...\ncmd = Environment.GetEnvironmentVariable(\"cmd\");\ncmd = cmd.Trim();\n\n\nSecurity problems caused by dereferencing null-pointers are almost always related to the way in which the program handles runtime exceptions. If the software has a solid and well-executed approach to dealing with runtime exceptions, the potential for security damage is significantly diminished.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8021/?engineType=SCA&issue=78E1DB3CBE184FE3528B2869DA7BFB0B"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8005",
          "shortDescription" : {
            "text" : "Cookie Security: Cookie not Sent Over SSL"
          },
          "fullDescription" : {
            "text" : "The method ButtonCheckEmail_Click() in forgotpassword.aspx.cs on line 48creates a cookie without the <code>secure</code> flag set to <code>true</code>.\n\n\n"
          },
          "help" : {
            "text" : "Modern web browsers support a secure flag for each cookie. If the flag is set, the browser will only send the cookie over HTTPS. Sending cookies over an unencrypted channel can expose them to network sniffing attacks, so the secure flag helps keep a cookie's value confidential. This is especially important if the cookie contains private data or carries a session identifier.\n\n\nIn this case, a cookie is created in forgotpassword.aspx.cs at line 42, but setSecure() is not called or is called with the value false.\n\n\nExample: In the following example, a cookie is added to the response without setting the Secure property.\n\n...\n HttpCookie cookie = new HttpCookie(\"emailCookie\", email);\n    Response.AppendCookie(cookie);\n...\n\n\nIf your application uses both HTTPS and HTTP but does not set the secure flag, cookies sent during an HTTPS request will also be sent during subsequent HTTP requests. Sniffing network traffic over unencrypted wireless connections is a trivial task for attackers, so sending cookies (especially those with session IDs) over HTTP can result in application compromise.\n\nSet the Secure flag on all new cookies in order to instruct browsers not to send these cookies in the clear.\nExample:\n\n...\n HttpCookie cookie = new HttpCookie(\"emailCookie\", email);\n    cookie.Secure = true;\n    Response.AppendCookie(cookie);\n\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8005/?engineType=SCA&issue=7005BEEC3A9F43E967589CC0D391B35F"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "8279",
          "shortDescription" : {
            "text" : "Privacy Violation"
          },
          "fullDescription" : {
            "text" : "The method ButtonRecoverPassword_Click() in forgotpassword.aspx.cs mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
          },
          "help" : {
            "text" : "Privacy violations occur when:\n\n1. Private user information enters the program.\n\n2. The data is written to an external location, such as the console, file system or network.\n\nIn this case, the data is passed to set_Text() in forgotpassword.aspx.cs at line 66.\n\nExample 1: The following code contains a logging statement that tracks the records added to a database by storing the contents in a log file.\n\n\npass = GetPassword();\n...\ndbmsLog.WriteLine(id+\":\"+pass+\":\"+type+\":\"+tstamp);\n\n\nThe code in Example 1 logs a plain text password to the file system. Although many developers trust the file system as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern.\n\nPrivate data can enter a program in a variety of ways:\n\n- Directly from the user in the form of a password or personal information\n\n- Accessed from a database or other data store by the application\n\n- Indirectly from a partner or other third party\n\nSometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private.\n\nSecurity and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can create risk.\n\nAlthough there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer email addresses to a spammer marketing an offshore gambling web site [1].\n\nIn response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:\n\n- Safe Harbor Privacy Framework [3]\n\n- Gramm-Leach Bliley Act (GLBA) [4]\n\n- Health Insurance Portability and Accountability Act (HIPAA) [5]\n\n- California SB-1386 [6]\n\nDespite these regulations, privacy violations continue to occur with alarming frequency.\n\nWhen security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.\n\nTo enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.\n\nThe best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8279/?engineType=SCA&issue=E103525EE8E39CD7A66FF4AABB038C09"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "8271",
          "shortDescription" : {
            "text" : "Header Manipulation: Cookies"
          },
          "fullDescription" : {
            "text" : "The method Page_Load() in headerinjection.aspx.cs includes unvalidated data in an HTTP cookie on line 19. This enables cookie manipulation attacks and can lead to other HTTP Response header manipulation attacks like: cache-poisoning, cross-site scripting, cross-user defacement, page hijacking or open redirect.\n\n\n"
          },
          "help" : {
            "text" : "Cookie Manipulation vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source, most frequently an HTTP request.\n\nIn this case, the data enters at get_QueryString() in headerinjection.aspx.cs at line 19.\n\n2. The data is included in an HTTP cookie sent to a web user without being validated.\n\nIn this case, the data is sent at set_Value() in headerinjection.aspx.cs at line 19.\n\nAs with many software security vulnerabilities, cookie manipulation is a means to an end, not an end in itself. At its root, the vulnerability is straightforward: an attacker passes malicious data to a vulnerable application, and the application includes the data in an HTTP cookie.\n\nCookie Manipulation: When combined with attacks like Cross-Site Request Forgery, attackers may change, add to, or even overwrite a legitimate user's cookies.\n\nBeing an HTTP Response header, cookie manipulation attacks can also lead to other types of attacks like:\n\nHTTP Response Splitting:\nOne of the most common Header Manipulation attacks is HTTP Response Splitting. To mount a successful HTTP Response Splitting exploit, the application must allow input that contains CR (carriage return, also given by %0d or \\r) and LF (line feed, also given by %0a or \n)characters into the header. These characters not only give attackers control of the remaining headers and body of the response the application intends to send, but also allows them to create additional responses entirely under their control.\n\nMany of today's modern application servers will prevent the injection of malicious characters into HTTP headers. For example, recent versions of Apache Tomcat will throw an IllegalArgumentException if you attempt to set a header with prohibited characters. If your application server prevents setting headers with new line characters, then your application is not vulnerable to HTTP Response Splitting. However, solely filtering for new line characters can leave an application vulnerable to Cookie Manipulation or Open Redirects, so care must still be taken when setting HTTP headers with user input.\n\nExample: The following code segment reads the name of the author of a weblog entry, author, from an HTTP request and sets it in a cookie header of an HTTP response.\n\n\nprotected System.Web.UI.WebControls.TextBox Author;\n...\nstring author = Author.Text;\nCookie cookie = new Cookie(\"author\", author);\n...\n\n\nAssuming a string consisting of standard alphanumeric characters, such as \"Jane Smith\", is submitted in the request the HTTP response including this cookie might take the following form:\n\n\nHTTP/1.1 200 OK\n...\nSet-Cookie: author=Jane Smith\n...\n\n\nHowever, because the value of the cookie is formed of unvalidated user input the response will only maintain this form if the value submitted for AUTHOR_PARAM does not contain any CR and LF characters. If an attacker submits a malicious string, such as \"Wiley Hacker\\r\nHTTP/1.1 200 OK\\r\n...\", then the HTTP response would be split into two responses of the following form:\n\n\nHTTP/1.1 200 OK\n...\nSet-Cookie: author=Wiley Hacker\n\nHTTP/1.1 200 OK\n...\n\n\nClearly, the second response is completely controlled by the attacker and can be constructed with any header and body content desired. The ability of attacker to construct arbitrary HTTP responses permits a variety of resulting attacks, including: cross-user defacement, web and browser cache poisoning, cross-site scripting, and page hijacking.\n\nCross-User Defacement: An attacker will be able to make a single request to a vulnerable server that will cause the server to create two responses, the second of which may be misinterpreted as a response to a different request, possibly one made by another user sharing the same TCP connection with the server. This can be accomplished by convincing the user to submit the malicious request themselves, or remotely in situations where the attacker and the user share a common TCP connection to the server, such as a shared proxy server. In the best case, an attacker may leverage this ability to convince users that the application has been hacked, causing users to lose confidence in the security of the application. In the worst case, an attacker may provide specially crafted content designed to mimic the behavior of the application but redirect private information, such as account numbers and passwords, back to the attacker.\n\nCache Poisoning: The impact of a maliciously constructed response can be magnified if it is cached either by a web cache used by multiple users or even the browser cache of a single user. If a response is cached in a shared web cache, such as those commonly found in proxy servers, then all users of that cache will continue receive the malicious content until the cache entry is purged. Similarly, if the response is cached in the browser of an individual user, then that user will continue to receive the malicious content until the cache entry is purged, although only the user of the local browser instance will be affected.\n\nCross-Site Scripting: Once attackers have control of the responses sent by an application, they have a choice of a variety of malicious content to provide users. Cross-site scripting is common form of attack where malicious JavaScript or other code included in a response is executed in the user's browser. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site. The most common and dangerous attack vector against users of a vulnerable application uses JavaScript to transmit session and authentication information back to the attacker who can then take complete control of the victim's account.\n\nPage Hijacking: In addition to using a vulnerable application to send malicious content to a user, the same root vulnerability can also be leveraged to redirect sensitive content generated by the server and intended for the user to the attacker instead. By submitting a request that results in two responses, the intended response from the server and the response generated by the attacker, an attacker may cause an intermediate node, such as a shared proxy server, to misdirect a response generated by the server for the user to the attacker. Because the request made by the attacker generates two responses, the first is interpreted as a response to the attacker's request, while the second remains in limbo. When the user makes a legitimate request through the same TCP connection, the attacker's request is already waiting and is interpreted as a response to the victim's request. The attacker then sends a second request to the server, to which the proxy server responds with the server generated request intended for the victim, thereby compromising any sensitive information in the headers or body of the response intended for the victim.\n\nOpen Redirect: Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.\n\nThe solution to cookie manipulation is to ensure that input validation occurs in the correct places and checks for the correct properties.\n\nSince Header Manipulation vulnerabilities like cookie manipulation occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating responses dynamically, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for Header Manipulation.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for Header Manipulation is generally relatively easy. Despite its value, input validation for Header Manipulation does not take the place of rigorous output validation. An application might accept input through a shared data store or other trusted source, and that data store might accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means that the best way to prevent Header Manipulation vulnerabilities is to validate everything that enters the application or leaves the application destined for the user.\n\nThe most secure approach to validation for Header Manipulation is to create an allow list of safe characters that are permitted to appear in HTTP response headers and accept input composed exclusively of characters in the approved set. For example, a valid name might only include alphanumeric characters or an account number might only include digits 0-9.\n\nA more flexible, but less secure approach is to implement a deny list, which selectively rejects or escapes potentially dangerous characters before using the input. To form such a list, you first need to understand the set of characters that hold special meaning in HTTP response headers. Although the CR and LF characters are at the heart of an HTTP response splitting attack, other characters, such as ':' (colon) and '=' (equal), have special meaning in response headers as well.\n\nAfter you identify the correct points in an application to perform validation for Header Manipulation attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. The application should reject any input destined to be included in HTTP response headers that contains special characters, particularly CR and LF, as invalid.\n\nMany application servers attempt to limit an application's exposure to HTTP response splitting vulnerabilities by providing implementations for the functions responsible for setting HTTP headers and cookies that perform validation for the characters essential to an HTTP response splitting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8271/?engineType=SCA&issue=DE85E5D1A941B7C96062AD851EE10748"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8003",
          "shortDescription" : {
            "text" : "Cookie Security: Cookie not Sent Over SSL"
          },
          "fullDescription" : {
            "text" : "The method Page_Load() in headerinjection.aspx.cs on line 21creates a cookie without the <code>secure</code> flag set to <code>true</code>.\n\n\n"
          },
          "help" : {
            "text" : "Modern web browsers support a secure flag for each cookie. If the flag is set, the browser will only send the cookie over HTTPS. Sending cookies over an unencrypted channel can expose them to network sniffing attacks, so the secure flag helps keep a cookie's value confidential. This is especially important if the cookie contains private data or carries a session identifier.\n\n\nIn this case, a cookie is created in headerinjection.aspx.cs at line 18, but setSecure() is not called or is called with the value false.\n\n\nExample: In the following example, a cookie is added to the response without setting the Secure property.\n\n...\n HttpCookie cookie = new HttpCookie(\"emailCookie\", email);\n    Response.AppendCookie(cookie);\n...\n\n\nIf your application uses both HTTPS and HTTP but does not set the secure flag, cookies sent during an HTTPS request will also be sent during subsequent HTTP requests. Sniffing network traffic over unencrypted wireless connections is a trivial task for attackers, so sending cookies (especially those with session IDs) over HTTP can result in application compromise.\n\nSet the Secure flag on all new cookies in order to instruct browsers not to send these cookies in the clear.\nExample:\n\n...\n HttpCookie cookie = new HttpCookie(\"emailCookie\", email);\n    cookie.Secure = true;\n    Response.AppendCookie(cookie);\n\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8003/?engineType=SCA&issue=6F90F18FAE59EF763331DFEE7C16AA47"
          },
          "properties" : {
            "tags" : [ "Low" ],
            "precision" : "low"
          }
        }, {
          "id" : "8225",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method Page_Load() in headerinjection.aspx.cs sends unvalidated data to a web browser on line 33, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of reflected XSS, the untrusted source is typically a web request, while in the case of persisted (also known as stored) XSS it is typically a database or other back-end data store.\n\n\nIn this case, the data enters at get_Headers() in headerinjection.aspx.cs at line 33.\n\n2. The data is included in dynamic content that is sent to a web user without validation.\n\nIn this case, the data is sent at set_Text() in headerinjection.aspx.cs at line 33.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but can also include HTML, Flash or any other type of code that the browser executes. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following ASP.NET Web Form reads an employee ID number from an HTTP request and displays it to the user.\n\n\n&lt;script runat=\"server\"&gt;\n...\nEmployeeID.Text = Login.Text;\n...\n&lt;/script&gt;\n\n\nWhere Login and EmployeeID are form controls defined as follows:\n\n\n&lt;form runat=\"server\"&gt;\n   &lt;asp:TextBox runat=\"server\" id=\"Login\"/&gt;\n   ...\n   &lt;asp:Label runat=\"server\" id=\"EmployeeID\"/&gt;\n&lt;/form&gt;\n\n\n\nExample 2: The following ASP.NET code segment shows the programmatic way to implement Example 1.\n\n\nprotected System.Web.UI.WebControls.TextBox Login;\nprotected System.Web.UI.WebControls.Label EmployeeID;\n...\nEmployeeID.Text = Login.Text;\n\n\n\nThe code in these examples operates correctly if Login contains only standard alphanumeric text. If Login has a value that includes metacharacters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL which causes malicious code to run on their own computer?  The real danger is that an attacker will create the malicious URL, then use email or social engineering tricks in order to lure victims into clicking a link. When the victims click the link, they unwittingly reflect the malicious content through the vulnerable web application and back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 3: The following ASP.NET Web Form queries a database for an employee with a given employee ID and prints the name corresponding with the ID.\n\n\n&lt;script runat=\"server\"&gt;\n...\nstring query = \"select * from emp where id=\" + eid;\nsda = new SqlDataAdapter(query, conn);\nDataTable dt = new DataTable();\nsda.Fill(dt);\nstring name = dt.Rows[0][\"Name\"];\n...\nEmployeeName.Text = name;\n&lt;/script&gt;\n\n\nWhere EmployeeName is a form control defined as follows:\n\n\n&lt;form runat=\"server\"&gt;\n   ...\n   &lt;asp:Label id=\"EmployeeName\" runat=\"server\"&gt;\n   ...\n&lt;/form&gt;\n\n\n\nExample 4: The following ASP.NET code segment is functionally equivalent to Example 3, but implements all of the form elements programmatically.\n\n\nprotected System.Web.UI.WebControls.Label EmployeeName;\n...\nstring query = \"select * from emp where id=\" + eid;\nsda = new SqlDataAdapter(query, conn);\nDataTable dt = new DataTable();\nsda.Fill(dt);\nstring name = dt.Rows[0][\"Name\"];\n...\nEmployeeName.Text = name;\n\n\n\nAs in Example 1 and Example 2, these code examples function correctly when the values of name are well-behaved, but they nothing to prevent exploits if the values are not. Again, these can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker may execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1 and Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or emailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 3 and Example 4, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\n\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks are made for the correct properties.\n\nBecause XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application might accept input through a shared data store or other trusted source, and that data store might accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means that the best way to prevent XSS vulnerabilities is to validate everything that enters the application and leaves the application destined for the user.\n\nThe most secure approach to validation for XSS is to create an allow list of safe characters that are permitted to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alphanumeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser must be considered valid input after they are encoded, such as a web design bulletin board that must accept HTML fragments from its users.\n\nA more flexible, but less secure approach is to implement a deny list, which selectively rejects or escapes potentially dangerous characters before using the input. To form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and might treat other characters as special in certain contexts, which is why we do not encourage the use of deny lists as a means to prevent XSS. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity.\n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything greater than 127 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- Semicolons, parentheses, curly braces, and new line characters should be filtered out in situations where text could be inserted directly into a pre-existing script tag.\n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering.\n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and might bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nAfter you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and might be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8225/?engineType=SCA&issue=CAD3231725190CC6A1881ED98346C672"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "7792",
          "shortDescription" : {
            "text" : "Log Forging"
          },
          "fullDescription" : {
            "text" : "The method btnDigest_Click() in messagedigest.aspx.cs writes unvalidated user input to the log on line 25. An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.\n\n\n"
          },
          "help" : {
            "text" : "Log forging vulnerabilities occur when:\n\n1.Data enters an application from an untrusted source.\n\nIn this case, the data enters at get_Text() in messagedigest.aspx.cs at line 25.\n\n2.The data is written to an application or system log file.\n\nIn this case, the data is logged by Info() in messagedigest.aspx.cs at line 25.\n\nApplications typically use log files to store a history of events or transactions for later review, statistics gathering, or debugging. Depending on the nature of the application, the task of reviewing log files may be performed manually on an as-needed basis or automated with a tool that automatically culls logs for important events or trending information.\n\nInterpretation of the log files may be hindered or misdirected if an attacker can supply data to the application that is subsequently logged verbatim. In the most benign case, an attacker may be able to insert false entries into the log file by providing the application with input that includes appropriate characters. If the log file is processed automatically, the attacker may be able to render the file unusable by corrupting the format of the file or injecting unexpected characters. A more subtle attack might involve skewing the log file statistics. Forged or otherwise, corrupted log files can be used to cover an attacker's tracks or even to implicate another party in the commission of a malicious act [1]. In the worst case, an attacker may inject code or other commands into the log file and take advantage of a vulnerability in the log processing utility [2].\n\nExample: The following web application code attempts to read an integer value from a request object. If the value fails to parse as an integer, then the input is logged with an error message indicating what happened.\n\n\n...\nstring val = (string)Session[\"val\"];\ntry {\nint value = Int32.Parse(val);\n}\ncatch (FormatException fe) {\nlog.Info(\"Failed to parse val= \" + val);\n}\n...\n\n\nIf a user submits the string \"twenty-one\" for val, the following entry is logged:\n\n\nINFO: Failed to parse val=twenty-one\n\n\nHowever, if an attacker submits the string \"twenty-one%0a%0aINFO:+User+logged+out%3dbadguy\", the following entry is logged:\n\n\nINFO: Failed to parse val=twenty-one\n\nINFO: User logged out=badguy\n\n\nClearly, attackers may use this same mechanism to insert arbitrary log entries.\n\nPrevent log forging attacks with indirection: create a set of legitimate log entries that correspond to different events that must be logged and only log entries from this set. To capture dynamic content, such as users logging out of the system, always use server-controlled values rather than user-supplied data. This ensures that the input provided by the user is never used directly in a log entry.\n\nIn some situations this approach is impractical because the set of legitimate log entries is too large or complicated. In these situations, developers often fall back on implementing a deny list. A deny list is used to selectively reject or escape potentially dangerous characters before using the input. However, a list of unsafe characters can quickly become incomplete or outdated. A better approach is to create a list of characters that are permitted to appear in log entries and accept input composed exclusively of characters in the approved set. The most critical character in most log forging attacks is the '\n' (newline) character, which should never appear on a log entry allow list.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/7792/?engineType=SCA&issue=27BDE6D1B9ED1376DFEDA5F43FAB4B30"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "7934",
          "shortDescription" : {
            "text" : "Path Manipulation"
          },
          "fullDescription" : {
            "text" : "Attackers can control the file system path argument to MapPath() at pathmanipulation.aspx.cs line 38, which allows them to access or modify otherwise protected files.\n\n\n"
          },
          "help" : {
            "text" : "Path manipulation errors occur when the following two conditions are met:\n\n1. An attacker can specify a path used in an operation on the file system.\n\n2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.\n\nFor example, the program might give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.\n\nIn this case, the attacker can specify the value that enters the program at get_QueryString() in pathmanipulation.aspx.cs at line 33, and this value is used to access a file system resource at MapPath() in pathmanipulation.aspx.cs at line 38.\n\n\nExample 1: The following code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker may provide a file name like \"..\\\\..\\\\Windows\\\\System32\\\\krnl386.exe\", which will cause the application to delete an important Windows system file.\n\n\nString rName = Request.Item(\"reportName\");\n...\nFile.delete(\"C:\\\\users\\\\reports\\\\\" + rName);\n\n\nExample 2: The following code uses input from a configuration file to determine which file to open and echo back to the user. If the program runs with adequate privileges and malicious users can change the configuration file, they can use the program to read any file on the system that ends with the extension \".txt\".\n\n\nsr = new StreamReader(resmngr.GetString(\"sub\")+\".txt\");\nwhile ((line = sr.ReadLine()) != null) {\nConsole.WriteLine(line);\n}\n\n\nThe best way to prevent path manipulation is with a level of indirection: create a list of legitimate values from which the user must select. With this approach, the user-provided input is never used directly to specify the resource name.\n\nIn some situations this approach is impractical because the set of legitimate resource names is too large or too hard to maintain. Programmers often resort to implementing a deny list in these situations. A deny list is used to selectively reject or escape potentially dangerous characters before using the input. However, any such list of unsafe characters is likely to be incomplete and will almost certainly become out of date. A better approach is to create a list of characters that are permitted to appear in the resource name and accept input composed exclusively of characters in the approved set.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/7934/?engineType=SCA&issue=5622923F2D3DC1279171A713867CD0C2"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "8072",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method Page_Load() in pathmanipulation.aspx.cs sends unvalidated data to a web browser on line 43, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of reflected XSS, the untrusted source is typically a web request, while in the case of persisted (also known as stored) XSS it is typically a database or other back-end data store.\n\n\nIn this case, the data enters at get_QueryString() in pathmanipulation.aspx.cs at line 33.\n\n2. The data is included in dynamic content that is sent to a web user without validation.\n\nIn this case, the data is sent at set_Text() in pathmanipulation.aspx.cs at line 43.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but can also include HTML, Flash or any other type of code that the browser executes. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following ASP.NET Web Form reads an employee ID number from an HTTP request and displays it to the user.\n\n\n&lt;script runat=\"server\"&gt;\n...\nEmployeeID.Text = Login.Text;\n...\n&lt;/script&gt;\n\n\nWhere Login and EmployeeID are form controls defined as follows:\n\n\n&lt;form runat=\"server\"&gt;\n   &lt;asp:TextBox runat=\"server\" id=\"Login\"/&gt;\n   ...\n   &lt;asp:Label runat=\"server\" id=\"EmployeeID\"/&gt;\n&lt;/form&gt;\n\n\n\nExample 2: The following ASP.NET code segment shows the programmatic way to implement Example 1.\n\n\nprotected System.Web.UI.WebControls.TextBox Login;\nprotected System.Web.UI.WebControls.Label EmployeeID;\n...\nEmployeeID.Text = Login.Text;\n\n\n\nThe code in these examples operates correctly if Login contains only standard alphanumeric text. If Login has a value that includes metacharacters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL which causes malicious code to run on their own computer?  The real danger is that an attacker will create the malicious URL, then use email or social engineering tricks in order to lure victims into clicking a link. When the victims click the link, they unwittingly reflect the malicious content through the vulnerable web application and back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 3: The following ASP.NET Web Form queries a database for an employee with a given employee ID and prints the name corresponding with the ID.\n\n\n&lt;script runat=\"server\"&gt;\n...\nstring query = \"select * from emp where id=\" + eid;\nsda = new SqlDataAdapter(query, conn);\nDataTable dt = new DataTable();\nsda.Fill(dt);\nstring name = dt.Rows[0][\"Name\"];\n...\nEmployeeName.Text = name;\n&lt;/script&gt;\n\n\nWhere EmployeeName is a form control defined as follows:\n\n\n&lt;form runat=\"server\"&gt;\n   ...\n   &lt;asp:Label id=\"EmployeeName\" runat=\"server\"&gt;\n   ...\n&lt;/form&gt;\n\n\n\nExample 4: The following ASP.NET code segment is functionally equivalent to Example 3, but implements all of the form elements programmatically.\n\n\nprotected System.Web.UI.WebControls.Label EmployeeName;\n...\nstring query = \"select * from emp where id=\" + eid;\nsda = new SqlDataAdapter(query, conn);\nDataTable dt = new DataTable();\nsda.Fill(dt);\nstring name = dt.Rows[0][\"Name\"];\n...\nEmployeeName.Text = name;\n\n\n\nAs in Example 1 and Example 2, these code examples function correctly when the values of name are well-behaved, but they nothing to prevent exploits if the values are not. Again, these can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker may execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1 and Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or emailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 3 and Example 4, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\n\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks are made for the correct properties.\n\nBecause XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application might accept input through a shared data store or other trusted source, and that data store might accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means that the best way to prevent XSS vulnerabilities is to validate everything that enters the application and leaves the application destined for the user.\n\nThe most secure approach to validation for XSS is to create an allow list of safe characters that are permitted to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alphanumeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser must be considered valid input after they are encoded, such as a web design bulletin board that must accept HTML fragments from its users.\n\nA more flexible, but less secure approach is to implement a deny list, which selectively rejects or escapes potentially dangerous characters before using the input. To form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and might treat other characters as special in certain contexts, which is why we do not encourage the use of deny lists as a means to prevent XSS. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity.\n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything greater than 127 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- Semicolons, parentheses, curly braces, and new line characters should be filtered out in situations where text could be inserted directly into a pre-existing script tag.\n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering.\n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and might bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nAfter you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and might be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8072/?engineType=SCA&issue=8C19B7FF6FC7DB38E9FE9650BAB31B27"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8173",
          "shortDescription" : {
            "text" : "Header Manipulation"
          },
          "fullDescription" : {
            "text" : "The method ResponseFile() in pathmanipulation.aspx.cs includes unvalidated data in an HTTP response header on line 79. This enables attacks such as cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.\n\n\n"
          },
          "help" : {
            "text" : "Header Manipulation vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source, most frequently an HTTP request.\n\nIn this case, the data enters at get_QueryString() in pathmanipulation.aspx.cs at line 33.\n\n\n2. The data is included in an HTTP response header sent to a web user without being validated.\n\nIn this case, the data is sent at AddHeader() in pathmanipulation.aspx.cs at line 79.\n\nAs with many software security vulnerabilities, Header Manipulation is a means to an end, not an end in itself. At its root, the vulnerability is straightforward: an attacker passes malicious data to a vulnerable application, and the application includes the data in an HTTP response header.\n\nOne of the most common Header Manipulation attacks is HTTP Response Splitting. To mount a successful HTTP Response Splitting exploit, the application must allow input that contains CR (carriage return, also given by %0d or \\r) and LF (line feed, also given by %0a or \n)characters into the header. These characters not only give attackers control of the remaining headers and body of the response the application intends to send, but also allows them to create additional responses entirely under their control.\n\nMany of today's modern application servers and frameworks will prevent the injection of malicious characters into HTTP headers. For example, recent versions of Microsoft's .NET framework will convert CR, LF, and NULL characters to %0d, %0a and %00 when they are sent to the HttpResponse.AddHeader() method. If you are using the latest .NET framework that prevents setting headers with new line characters, then your application might not be vulnerable to HTTP Response Splitting. However, solely filtering for new line characters can leave an application vulnerable to Cookie Manipulation or Open Redirects, so care must still be taken when setting HTTP headers with user input.\n\nExample: The following code segment reads the name of the author of a weblog entry, author, from an HTTP request and sets it in a cookie header of an HTTP response.\n\n\nprotected System.Web.UI.WebControls.TextBox Author;\n...\nstring author = Author.Text;\nCookie cookie = new Cookie(\"author\", author);\n...\n\n\nAssuming a string consisting of standard alphanumeric characters, such as \"Jane Smith\", is submitted in the request the HTTP response including this cookie might take the following form:\n\n\nHTTP/1.1 200 OK\n...\nSet-Cookie: author=Jane Smith\n...\n\n\nHowever, because the value of the cookie is formed of unvalidated user input the response will only maintain this form if the value submitted for Author.Text does not contain any CR and LF characters. If an attacker submits a malicious string, such as \"Wiley Hacker\\r\nHTTP/1.1 200 OK\\r\n...\", then the HTTP response would be split into two responses of the following form:\n\n\nHTTP/1.1 200 OK\n...\nSet-Cookie: author=Wiley Hacker\n\nHTTP/1.1 200 OK\n...\n\n\nClearly, the second response is completely controlled by the attacker and can be constructed with any header and body content desired. The ability of attacker to construct arbitrary HTTP responses permits a variety of resulting attacks, including: cross-user defacement, web and browser cache poisoning, cross-site scripting, and page hijacking.\n\nCross-User Defacement: An attacker will be able to make a single request to a vulnerable server that will cause the server to create two responses, the second of which may be misinterpreted as a response to a different request, possibly one made by another user sharing the same TCP connection with the server. This can be accomplished by convincing the user to submit the malicious request themselves, or remotely in situations where the attacker and the user share a common TCP connection to the server, such as a shared proxy server. In the best case, an attacker may leverage this ability to convince users that the application has been hacked, causing users to lose confidence in the security of the application. In the worst case, an attacker may provide specially crafted content designed to mimic the behavior of the application but redirect private information, such as account numbers and passwords, back to the attacker.\n\nCache Poisoning: The impact of a maliciously constructed response can be magnified if it is cached either by a web cache used by multiple users or even the browser cache of a single user. If a response is cached in a shared web cache, such as those commonly found in proxy servers, then all users of that cache will continue receive the malicious content until the cache entry is purged. Similarly, if the response is cached in the browser of an individual user, then that user will continue to receive the malicious content until the cache entry is purged, although only the user of the local browser instance will be affected.\n\nCross-Site Scripting: Once attackers have control of the responses sent by an application, they have a choice of a variety of malicious content to provide users. Cross-site scripting is common form of attack where malicious JavaScript or other code included in a response is executed in the user's browser. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site. The most common and dangerous attack vector against users of a vulnerable application uses JavaScript to transmit session and authentication information back to the attacker who can then take complete control of the victim's account.\n\nPage Hijacking: In addition to using a vulnerable application to send malicious content to a user, the same root vulnerability can also be leveraged to redirect sensitive content generated by the server and intended for the user to the attacker instead. By submitting a request that results in two responses, the intended response from the server and the response generated by the attacker, an attacker may cause an intermediate node, such as a shared proxy server, to misdirect a response generated by the server for the user to the attacker. Because the request made by the attacker generates two responses, the first is interpreted as a response to the attacker's request, while the second remains in limbo. When the user makes a legitimate request through the same TCP connection, the attacker's request is already waiting and is interpreted as a response to the victim's request. The attacker then sends a second request to the server, to which the proxy server responds with the server generated request intended for the victim, thereby compromising any sensitive information in the headers or body of the response intended for the victim.\n\nCookie Manipulation: When combined with attacks like Cross-Site Request Forgery, attackers may change, add to, or even overwrite a legitimate user's cookies.\n\nOpen Redirect: Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.\n\nThe solution to Header Manipulation is to ensure that input validation occurs in the correct places and checks for the correct properties.\n\nSince Header Manipulation vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating responses dynamically, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for Header Manipulation.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for Header Manipulation is generally relatively easy. Despite its value, input validation for Header Manipulation does not take the place of rigorous output validation. An application might accept input through a shared data store or other trusted source, and that data store might accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means that the best way to prevent Header Manipulation vulnerabilities is to validate everything that enters the application or leaves the application destined for the user.\n\nThe most secure approach to validation for Header Manipulation is to create an allow list of safe characters that are permitted to appear in HTTP response headers and accept input composed exclusively of characters in the approved set. For example, a valid name might only include alphanumeric characters or an account number might only include digits 0-9.\n\nA more flexible, but less secure approach is to implement a deny list, which selectively rejects or escapes potentially dangerous characters before using the input. To form such a list, you first need to understand the set of characters that hold special meaning in HTTP response headers. Although the CR and LF characters are at the heart of an HTTP response splitting attack, other characters, such as ':' (colon) and '=' (equal), have special meaning in response headers as well.\n\nAfter you identify the correct points in an application to perform validation for Header Manipulation attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. The application should reject any input destined to be included in HTTP response headers that contains special characters, particularly CR and LF, as invalid.\n\nMany application servers attempt to limit an application's exposure to HTTP response splitting vulnerabilities by providing implementations for the functions responsible for setting HTTP headers and cookies that perform validation for the characters essential to an HTTP response splitting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8173/?engineType=SCA&issue=B8A11F63D5F15A4FF9787AC89AC012B8"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8132",
          "shortDescription" : {
            "text" : "ASP.NET Bad Practices: Non-Serializable Object Stored in Session"
          },
          "fullDescription" : {
            "text" : "The method Reset() in random.aspx.cs stores a non-serializable object as an <code>HttpSessionState</code> attribute on line 65, which can damage application reliability.\n\n\n"
          },
          "help" : {
            "text" : "By default, ASP.NET servers store the HttpSessionState object, its attributes and any objects they reference in memory. This model limits active session state to what can be accommodated by the system memory of a single machine. In order to expand capacity beyond these limitations, servers are frequently configured to persistent session state information, which both expands capacity and permits the replication across multiple machines to improve overall performance. In order to persist its session state, the server must serialize the HttpSessionState object, which requires that all objects stored in it be serializable.\n\nIn order for the session to be serialized correctly, all objects the application stores as session attributes must declare the [Serializable] attribute. Additionally, if the object requires custom serialization methods, it must also implement the ISerializable interface.\n\nExample 1: The following class adds itself to the session, but since it is not serializable, the session cannot be serialized correctly.\n\n\npublic class DataGlob {\n   String GlobName;\n   String GlobValue;\n\n   public void AddToSession(HttpSessionState session) {\n     session[\"glob\"] = this;\n   }\n}\n\n\nIn many cases, the easiest way to fix this problem is to have the offending object declare the [Serializable] attribute. If the class requires custom serialization and deserialization methods, it must also implement the ISerializable interface.\n\nExample 2: The code in Example 1 could be rewritten in the following way:\n\n\nusing System.Web;\n\nnamespace glob{\n\n[Serializable]\npublic class DataGlob {\n   String GlobName;\n   String GlobValue;\n\n   public void AddToSession(HttpSessionState session) {\n     session[\"glob\"] = this;\n   }\n}\n\n}\n\n\nGenerally, implementing a serializable class is straightforward. However, some types of objects will require special treatment. Watch out for objects that hold references to external resources, such as streams and pointers, which are likely to cause complications.\n\nNote that for complex objects, the transitive closure of the objects stored in the session must be serializable. For example, if object A references object B and object A is stored in the session, then both A and B must declare the [Serializable] attribute and implement any necessary serialization or deserialization methods.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8132/?engineType=SCA&issue=A731707370CC356514C46E02F21C759B"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8299",
          "shortDescription" : {
            "text" : "Value Shadowing"
          },
          "fullDescription" : {
            "text" : "The function Page_Load() in reflectedxss.aspx.cs accesses a variable in an ambiguous way at line 19, which can leave the program open to attack.\n\n\n"
          },
          "help" : {
            "text" : "The HttpRequest class provides programmatic access to variables from the QueryString, Form, Cookies or ServerVariables collections in the form of an array access (e.g. Request[\"myParam\"]). When more than one variable exists with the same name, the .NET framework returns the value of the variable that appears first when the collections are searched in the following order: QueryString, Form, Cookies then ServerVariables. Since QueryString comes first in the search order, it is possible for QueryString parameters to supersede values from forms, cookies, and server variables. Similarly, form values can supersede variables in the Cookies and ServerVariables collections and variables from the Cookies collection can supersede those from ServerVariables.\n\nIn this case, the value of a variable accessed from an HttpRequest object at line 19 in reflectedxss.aspx.cs can be superseded by an attacker.\n\nExample 1: Imagine a banking application temporarily stores a user's email address in a cookie and reads this value when it wants to contact the user. The following code reads the cookie value and sends an account balance to the specified email address.\n\n...\n    String toAddress = Request[\"email\"];        //Expects cookie value\n    Double balance = GetBalance(userID);\n    SendAccountBalance(toAddress, balance);\n...\n\nAssume the code in Example 1 is executed when visiting http://www.example.com/GetBalance.aspx. If an attacker can cause an authenticated user to click a link that requests http://www.example.com/GetBalance.aspx?email=evil%40evil.com, an email with the user's account balance will be sent to evil@evil.com.\n\nDo not make use of the .NET convenience mechanism for searching multiple collections through an HttpRequest object. Instead, read values directly from the relevant collection or implement your own explicit search order in situations where the desired value might be found in multiple collections.\n\nExample 2: The following code implements the same functionality as Example 1, but instead of accessing the user's email address through the Request object, it accesses the Cookies collection explicitly.\n\n...\n    String toAddress = Request.Cookies[\"email\"];\n    Double balance = GetBalance(userID);\n    SendAccountBalance(toAddress, balance);\n...\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8299/?engineType=SCA&issue=EA6B8E0CED9F959039B586044075FC75"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8298",
          "shortDescription" : {
            "text" : "Value Shadowing"
          },
          "fullDescription" : {
            "text" : "The function Page_Load() in reflectedxss.aspx.cs accesses a variable in an ambiguous way at line 20, which can leave the program open to attack.\n\n\n"
          },
          "help" : {
            "text" : "The HttpRequest class provides programmatic access to variables from the QueryString, Form, Cookies or ServerVariables collections in the form of an array access (e.g. Request[\"myParam\"]). When more than one variable exists with the same name, the .NET framework returns the value of the variable that appears first when the collections are searched in the following order: QueryString, Form, Cookies then ServerVariables. Since QueryString comes first in the search order, it is possible for QueryString parameters to supersede values from forms, cookies, and server variables. Similarly, form values can supersede variables in the Cookies and ServerVariables collections and variables from the Cookies collection can supersede those from ServerVariables.\n\nIn this case, the value of a variable accessed from an HttpRequest object at line 20 in reflectedxss.aspx.cs can be superseded by an attacker.\n\nExample 1: Imagine a banking application temporarily stores a user's email address in a cookie and reads this value when it wants to contact the user. The following code reads the cookie value and sends an account balance to the specified email address.\n\n...\n    String toAddress = Request[\"email\"];        //Expects cookie value\n    Double balance = GetBalance(userID);\n    SendAccountBalance(toAddress, balance);\n...\n\nAssume the code in Example 1 is executed when visiting http://www.example.com/GetBalance.aspx. If an attacker can cause an authenticated user to click a link that requests http://www.example.com/GetBalance.aspx?email=evil%40evil.com, an email with the user's account balance will be sent to evil@evil.com.\n\nDo not make use of the .NET convenience mechanism for searching multiple collections through an HttpRequest object. Instead, read values directly from the relevant collection or implement your own explicit search order in situations where the desired value might be found in multiple collections.\n\nExample 2: The following code implements the same functionality as Example 1, but instead of accessing the user's email address through the Request object, it accesses the Cookies collection explicitly.\n\n...\n    String toAddress = Request.Cookies[\"email\"];\n    Double balance = GetBalance(userID);\n    SendAccountBalance(toAddress, balance);\n...\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8298/?engineType=SCA&issue=EA6B8E0CED9F959039B586044075FC74"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8281",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method LoadCity() in reflectedxss.aspx.cs sends unvalidated data to a web browser on line 26, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of reflected XSS, the untrusted source is typically a web request, while in the case of persisted (also known as stored) XSS it is typically a database or other back-end data store.\n\n\nIn this case, the data enters at get_Item() in reflectedxss.aspx.cs at line 20.\n\n2. The data is included in dynamic content that is sent to a web user without validation.\n\nIn this case, the data is sent at set_Text() in reflectedxss.aspx.cs at line 26.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but can also include HTML, Flash or any other type of code that the browser executes. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following ASP.NET Web Form reads an employee ID number from an HTTP request and displays it to the user.\n\n\n&lt;script runat=\"server\"&gt;\n...\nEmployeeID.Text = Login.Text;\n...\n&lt;/script&gt;\n\n\nWhere Login and EmployeeID are form controls defined as follows:\n\n\n&lt;form runat=\"server\"&gt;\n   &lt;asp:TextBox runat=\"server\" id=\"Login\"/&gt;\n   ...\n   &lt;asp:Label runat=\"server\" id=\"EmployeeID\"/&gt;\n&lt;/form&gt;\n\n\n\nExample 2: The following ASP.NET code segment shows the programmatic way to implement Example 1.\n\n\nprotected System.Web.UI.WebControls.TextBox Login;\nprotected System.Web.UI.WebControls.Label EmployeeID;\n...\nEmployeeID.Text = Login.Text;\n\n\n\nThe code in these examples operates correctly if Login contains only standard alphanumeric text. If Login has a value that includes metacharacters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL which causes malicious code to run on their own computer?  The real danger is that an attacker will create the malicious URL, then use email or social engineering tricks in order to lure victims into clicking a link. When the victims click the link, they unwittingly reflect the malicious content through the vulnerable web application and back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 3: The following ASP.NET Web Form queries a database for an employee with a given employee ID and prints the name corresponding with the ID.\n\n\n&lt;script runat=\"server\"&gt;\n...\nstring query = \"select * from emp where id=\" + eid;\nsda = new SqlDataAdapter(query, conn);\nDataTable dt = new DataTable();\nsda.Fill(dt);\nstring name = dt.Rows[0][\"Name\"];\n...\nEmployeeName.Text = name;\n&lt;/script&gt;\n\n\nWhere EmployeeName is a form control defined as follows:\n\n\n&lt;form runat=\"server\"&gt;\n   ...\n   &lt;asp:Label id=\"EmployeeName\" runat=\"server\"&gt;\n   ...\n&lt;/form&gt;\n\n\n\nExample 4: The following ASP.NET code segment is functionally equivalent to Example 3, but implements all of the form elements programmatically.\n\n\nprotected System.Web.UI.WebControls.Label EmployeeName;\n...\nstring query = \"select * from emp where id=\" + eid;\nsda = new SqlDataAdapter(query, conn);\nDataTable dt = new DataTable();\nsda.Fill(dt);\nstring name = dt.Rows[0][\"Name\"];\n...\nEmployeeName.Text = name;\n\n\n\nAs in Example 1 and Example 2, these code examples function correctly when the values of name are well-behaved, but they nothing to prevent exploits if the values are not. Again, these can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker may execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1 and Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or emailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 3 and Example 4, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\n\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks are made for the correct properties.\n\nBecause XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application might accept input through a shared data store or other trusted source, and that data store might accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means that the best way to prevent XSS vulnerabilities is to validate everything that enters the application and leaves the application destined for the user.\n\nThe most secure approach to validation for XSS is to create an allow list of safe characters that are permitted to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alphanumeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser must be considered valid input after they are encoded, such as a web design bulletin board that must accept HTML fragments from its users.\n\nA more flexible, but less secure approach is to implement a deny list, which selectively rejects or escapes potentially dangerous characters before using the input. To form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and might treat other characters as special in certain contexts, which is why we do not encourage the use of deny lists as a means to prevent XSS. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity.\n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything greater than 127 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- Semicolons, parentheses, curly braces, and new line characters should be filtered out in situations where text could be inserted directly into a pre-existing script tag.\n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering.\n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and might bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nAfter you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and might be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8281/?engineType=SCA&issue=E31C362F7F402CEAECC7194F2724EC8E"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8314",
          "shortDescription" : {
            "text" : "Denial of Service: Regular Expression"
          },
          "fullDescription" : {
            "text" : "Untrusted data is passed to the application and used as a regular expression. This can cause the thread to overconsume CPU resources.\n\n\n"
          },
          "help" : {
            "text" : "There is a vulnerability in implementations of regular expression evaluators and related methods that can cause the thread to hang when evaluating regular expressions that contain a grouping expression that is itself repeated. Additionally, any regular expression that contains alternate subexpressions that overlap one another can also be exploited. This defect can be used to execute a Denial of Service (DoS) attack.\nExample:\n\n  (e+)+\n  ([a-zA-Z]+)*\n  (e|ee)+\n\nThere are no known regular expression implementations that are immune to this vulnerability. All platforms and languages are vulnerable to this attack.\n\nDo not allow untrusted data to be used as regular expression patterns. If this solution is impractical for your application, Microsoft recommends to set the matchTimeout parameter to an appropriate value, such as two seconds. \n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8314/?engineType=SCA&issue=F390DDB21A93A0C2A4913E57CC449DAD"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "7945",
          "shortDescription" : {
            "text" : "Cross-Site Scripting: Reflected"
          },
          "fullDescription" : {
            "text" : "The method Page_Load() in verbtampering.aspx.cs sends unvalidated data to a web browser on line 15, which can result in the browser executing malicious code.\n\n\n"
          },
          "help" : {
            "text" : "Cross-site scripting (XSS) vulnerabilities occur when:\n\n1. Data enters a web application through an untrusted source. In the case of reflected XSS, the untrusted source is typically a web request, while in the case of persisted (also known as stored) XSS it is typically a database or other back-end data store.\n\n\nIn this case, the data enters at get_QueryString() in verbtamperingattack.aspx.cs at line 14.\n\n2. The data is included in dynamic content that is sent to a web user without validation.\n\nIn this case, the data is sent at set_Text() in verbtampering.aspx.cs at line 15.\n\nThe malicious content sent to the web browser often takes the form of a segment of JavaScript, but can also include HTML, Flash or any other type of code that the browser executes. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.\n\nExample 1: The following ASP.NET Web Form reads an employee ID number from an HTTP request and displays it to the user.\n\n\n&lt;script runat=\"server\"&gt;\n...\nEmployeeID.Text = Login.Text;\n...\n&lt;/script&gt;\n\n\nWhere Login and EmployeeID are form controls defined as follows:\n\n\n&lt;form runat=\"server\"&gt;\n   &lt;asp:TextBox runat=\"server\" id=\"Login\"/&gt;\n   ...\n   &lt;asp:Label runat=\"server\" id=\"EmployeeID\"/&gt;\n&lt;/form&gt;\n\n\n\nExample 2: The following ASP.NET code segment shows the programmatic way to implement Example 1.\n\n\nprotected System.Web.UI.WebControls.TextBox Login;\nprotected System.Web.UI.WebControls.Label EmployeeID;\n...\nEmployeeID.Text = Login.Text;\n\n\n\nThe code in these examples operates correctly if Login contains only standard alphanumeric text. If Login has a value that includes metacharacters or source code, then the code will be executed by the web browser as it displays the HTTP response.\n\nInitially this might not appear to be much of a vulnerability. After all, why would someone enter a URL which causes malicious code to run on their own computer?  The real danger is that an attacker will create the malicious URL, then use email or social engineering tricks in order to lure victims into clicking a link. When the victims click the link, they unwittingly reflect the malicious content through the vulnerable web application and back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.\n\nExample 3: The following ASP.NET Web Form queries a database for an employee with a given employee ID and prints the name corresponding with the ID.\n\n\n&lt;script runat=\"server\"&gt;\n...\nstring query = \"select * from emp where id=\" + eid;\nsda = new SqlDataAdapter(query, conn);\nDataTable dt = new DataTable();\nsda.Fill(dt);\nstring name = dt.Rows[0][\"Name\"];\n...\nEmployeeName.Text = name;\n&lt;/script&gt;\n\n\nWhere EmployeeName is a form control defined as follows:\n\n\n&lt;form runat=\"server\"&gt;\n   ...\n   &lt;asp:Label id=\"EmployeeName\" runat=\"server\"&gt;\n   ...\n&lt;/form&gt;\n\n\n\nExample 4: The following ASP.NET code segment is functionally equivalent to Example 3, but implements all of the form elements programmatically.\n\n\nprotected System.Web.UI.WebControls.Label EmployeeName;\n...\nstring query = \"select * from emp where id=\" + eid;\nsda = new SqlDataAdapter(query, conn);\nDataTable dt = new DataTable();\nsda.Fill(dt);\nstring name = dt.Rows[0][\"Name\"];\n...\nEmployeeName.Text = name;\n\n\n\nAs in Example 1 and Example 2, these code examples function correctly when the values of name are well-behaved, but they nothing to prevent exploits if the values are not. Again, these can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker may execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a \"guestbook\" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.\n\nAs the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:\n\n- As in Example 1 and Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or emailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.\n\n- As in Example 3 and Example 4, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.\n\n- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.\n\n\n\nThe solution to XSS is to ensure that validation occurs in the correct places and checks are made for the correct properties.\n\nBecause XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.\n\nWeb applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application might accept input through a shared data store or other trusted source, and that data store might accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means that the best way to prevent XSS vulnerabilities is to validate everything that enters the application and leaves the application destined for the user.\n\nThe most secure approach to validation for XSS is to create an allow list of safe characters that are permitted to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alphanumeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser must be considered valid input after they are encoded, such as a web design bulletin board that must accept HTML fragments from its users.\n\nA more flexible, but less secure approach is to implement a deny list, which selectively rejects or escapes potentially dangerous characters before using the input. To form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and might treat other characters as special in certain contexts, which is why we do not encourage the use of deny lists as a means to prevent XSS. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:\n\nIn the content of a block-level element (in the middle of a paragraph of text):\n\n- \"&lt;\" is special because it introduces a tag.\n\n- \"&amp;\" is special because it introduces a character entity.\n\n- \"&gt;\" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening \"&lt;\", but omitted it in error.\n\nThe following principles apply to attribute values:\n\n- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.\n\n- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.\n\n- In attribute values without any quotes, white-space characters, such as space and tab, are special.\n\n- \"&amp;\" is special when used with certain attributes, because it introduces a character entity.\n\nIn URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:\n\n- Space, tab, and new line are special because they mark the end of the URL.\n\n- \"&amp;\" is special because it either introduces a character entity or separates CGI parameters.\n\n- Non-ASCII characters (that is, everything greater than 127 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.\n\n- The \"%\" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, \"%\" must be filtered if input such as \"%68%65%6C%6C%6F\" becomes \"hello\" when it appears on the web page in question.\n\nWithin the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:\n\n- Semicolons, parentheses, curly braces, and new line characters should be filtered out in situations where text could be inserted directly into a pre-existing script tag.\n\nServer-side scripts:\n\n- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (\") on output might require additional filtering.\n\nOther possibilities:\n\n- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and might bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).\n\nAfter you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and might be unacceptable in circumstances where the integrity of the input must be preserved for display.\n\nIf input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].\n\nMany application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/7945/?engineType=SCA&issue=595C66E5636600D50B491FA86A0CFED1"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8350",
          "shortDescription" : {
            "text" : "XPath Injection"
          },
          "fullDescription" : {
            "text" : "On line 28 of xpathinjection.aspx.cs, the method FindSalesPerson() invokes an XPath query built using unvalidated input. This call could allow an attacker to modify the statement's meaning or to execute arbitrary XPath queries.\n\n\n"
          },
          "help" : {
            "text" : "XPath injection occurs when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case, the data enters at get_QueryString() in xpathinjection.aspx.cs at line 20.\n\n\n\n2. The data used to dynamically construct an XPath query.\n\n\nIn this case, the query is passed to SelectNodes() in xpathinjection.aspx.cs at line 28.\n\n\nExample 1: The following code dynamically constructs and executes an XPath query that retrieves an email address for a given account ID. The account ID is read from an HTTP request, and is therefore untrusted.\n\n\n...\nstring acctID = Request[\"acctID\"];\nstring query = null;\nif(acctID != null) {\n       StringBuffer sb = new StringBuffer(\"/accounts/account[acctID='\");\n       sb.append(acctID);\n       sb.append(\"']/email/text()\");\n       query = sb.toString();\n}\n\nXPathDocument docNav = new XPathDocument(myXml);\nXPathNavigator nav = docNav.CreateNavigator();\nnav.Evaluate(query);\n...\n\n\nUnder normal conditions, such as searching for an email address that belongs to the account number 1, the query that this code executes will look like the following:\n\n/accounts/account[acctID='1']/email/text()\n\nHowever, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if acctID does not contain a single-quote character. If an attacker enters the string 1' or '1' = '1 for acctID, then the query becomes the following:\n\n/accounts/account[acctID='1' or '1' = '1']/email/text()\n\nThe addition of the 1' or '1' = '1 condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n//email/text()\n\nThis simplification of the query allows the attacker to bypass the requirement that the query must only return items owned by the authenticated user. The query now returns all email addresses stored in the document, regardless of their specified owner.\n\nThe root cause of XPath injection vulnerability is the ability of an attacker to change context in the XPath query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When an XPath query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data.\n\nTo prevent an attacker from violating the programmer's expectations, use an allow list to ensure that user-controlled values used in an XPath query are composed from only the expected set of characters and do not contain any XPath metacharacters given the context in which they are used. If a user-controlled value requires that it contain XPath metacharacters, use an appropriate encoding mechanism to remove their significance within the XPath query.\n\nExample 2\n\n...\nstring acctID = Request[\"acctID\"];\nstring query = null;\nif(acctID != null) {\n       try {\n              iAcctID = Int32.Parse(acctID);\n       }\n       catch (FormatException e) {\n              throw new InvalidParameterException();\n       }\n       StringBuffer sb = new StringBuffer(\"/accounts/account[acctID='\");\n       sb.append(acctID.toString());\n       sb.append(\"']/email/text()\");\n       query = sb.toString();\n}\n\nXPathDocument docNav = new XPathDocument(myXml);\nXPathNavigator nav = docNav.CreateNavigator();\nnav.Evaluate(query);\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8350/?engineType=SCA&issue=FF9040486E29A08396CE69941B06E8D8"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "8046",
          "shortDescription" : {
            "text" : "Password Management: Hardcoded Password"
          },
          "fullDescription" : {
            "text" : "Hardcoded passwords can compromise system security in a way that is not easy to remedy.\n\n\n"
          },
          "help" : {
            "text" : "It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. After the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system must choose between security and availability.\n\nExample: The following code uses a hardcoded password to create a network credential:\n\n\n...\nNetworkCredential netCred =\n           new NetworkCredential(\"scott\", \"tiger\", domain);\n...\n\n\nThis code will run successfully, but anyone who has access to it will have access to the password. After the program ships, there is likely no way to change the network credential user \"scott\" with a password of \"tiger\" unless the program is patched. An employee with access to this information can use it to break into the system. If attackers have access to the executable for the application they can disassemble the code, which will contain the values of the passwords used.\n\nPasswords should never be hardcoded and should generally be obfuscated and managed in an external source. Storing passwords in plain text anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password.\n\nMicrosoft(R) provides a tool that can be used in conjunction with the Windows Data Protection application programming interface (DPAPI) to protect sensitive application entries in configuration files [1].\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8046/?engineType=SCA&issue=8300BCE32737B84CC6762AC07491A5F4"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8204",
          "shortDescription" : {
            "text" : "Log Forging"
          },
          "fullDescription" : {
            "text" : "The method GenerateWeakDigest() in WeakMessageDigest.cs writes unvalidated user input to the log on line 26. An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.\n\n\n"
          },
          "help" : {
            "text" : "Log forging vulnerabilities occur when:\n\n1.Data enters an application from an untrusted source.\n\nIn this case, the data enters at get_Text() in messagedigest.aspx.cs at line 23.\n\n2.The data is written to an application or system log file.\n\nIn this case, the data is logged by Debug() in WeakMessageDigest.cs at line 26.\n\nApplications typically use log files to store a history of events or transactions for later review, statistics gathering, or debugging. Depending on the nature of the application, the task of reviewing log files may be performed manually on an as-needed basis or automated with a tool that automatically culls logs for important events or trending information.\n\nInterpretation of the log files may be hindered or misdirected if an attacker can supply data to the application that is subsequently logged verbatim. In the most benign case, an attacker may be able to insert false entries into the log file by providing the application with input that includes appropriate characters. If the log file is processed automatically, the attacker may be able to render the file unusable by corrupting the format of the file or injecting unexpected characters. A more subtle attack might involve skewing the log file statistics. Forged or otherwise, corrupted log files can be used to cover an attacker's tracks or even to implicate another party in the commission of a malicious act [1]. In the worst case, an attacker may inject code or other commands into the log file and take advantage of a vulnerability in the log processing utility [2].\n\nExample: The following web application code attempts to read an integer value from a request object. If the value fails to parse as an integer, then the input is logged with an error message indicating what happened.\n\n\n...\nstring val = (string)Session[\"val\"];\ntry {\nint value = Int32.Parse(val);\n}\ncatch (FormatException fe) {\nlog.Info(\"Failed to parse val= \" + val);\n}\n...\n\n\nIf a user submits the string \"twenty-one\" for val, the following entry is logged:\n\n\nINFO: Failed to parse val=twenty-one\n\n\nHowever, if an attacker submits the string \"twenty-one%0a%0aINFO:+User+logged+out%3dbadguy\", the following entry is logged:\n\n\nINFO: Failed to parse val=twenty-one\n\nINFO: User logged out=badguy\n\n\nClearly, attackers may use this same mechanism to insert arbitrary log entries.\n\nPrevent log forging attacks with indirection: create a set of legitimate log entries that correspond to different events that must be logged and only log entries from this set. To capture dynamic content, such as users logging out of the system, always use server-controlled values rather than user-supplied data. This ensures that the input provided by the user is never used directly in a log entry.\n\nIn some situations this approach is impractical because the set of legitimate log entries is too large or complicated. In these situations, developers often fall back on implementing a deny list. A deny list is used to selectively reject or escape potentially dangerous characters before using the input. However, a list of unsafe characters can quickly become incomplete or outdated. A better approach is to create a list of characters that are permitted to appear in log entries and accept input composed exclusively of characters in the approved set. The most critical character in most log forging attacks is the '\n' (newline) character, which should never appear on a log entry allow list.\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8204/?engineType=SCA&issue=C59F2FA4B9CC20EC5AF35B4C642D8D8C"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "7989",
          "shortDescription" : {
            "text" : "Cookie Security: Session Cookie not Sent Over SSL"
          },
          "fullDescription" : {
            "text" : "The application session cookie is created without the <code>secure</code> flag set to <code>true</code>.\n\n\n"
          },
          "help" : {
            "text" : "Modern web browsers support a secure flag for each cookie. If the flag is set, the browser will only send the cookie over HTTPS. Sending cookies over an unencrypted channel can expose them to network sniffing attacks, so the secure flag helps keep a cookie's value confidential. This is especially important if the cookie contains private data or carries a session identifier.\n\nIn this case the session cookie created in Web.config at line 56, does not have its secure flag set to true.\n\n\nExample 1: A configuration that results in the session cookie being added to the response without setting the Secure flag.\n\n...\n&lt;configuration&gt;\n   &lt;system.web&gt;\n   &lt;authentication mode=\"Forms\"&gt;\n      &lt;forms requireSSL=\"false\" loginUrl=\"login.aspx\"&gt;\n      &lt;/forms&gt;\n   &lt;/authentication&gt;\n   &lt;/system.web&gt;\n&lt;/configuration&gt;\n...\n\n\nIf your application uses both HTTPS and HTTP but does not set the secure flag, cookies sent during an HTTPS request will also be sent during subsequent HTTP requests. Sniffing network traffic over unencrypted wireless connections is a trivial task for attackers, so sending cookies (especially those with session IDs) over HTTP can result in application compromise.\n\nSet the Secure flag on all new cookies in order to instruct browsers not to send these cookies in the clear.\nExample 2: The following configuration specifies requireSSL=\"true\" to ensure the Secure flag is set on cookies.\n\n...\n&lt;configuration&gt;\n   &lt;system.web&gt;\n   &lt;authentication mode=\"Forms\"&gt;\n      &lt;forms requireSSL=\"true\" loginUrl=\"login.aspx\"&gt;\n      &lt;/forms&gt;\n   &lt;/authentication&gt;\n   &lt;/system.web&gt;\n&lt;/configuration&gt;\n...\n\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/7989/?engineType=SCA&issue=6AB1F075ED1868B976DF091E3E05D60E"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8078",
          "shortDescription" : {
            "text" : "Password Management: Password in Configuration File"
          },
          "fullDescription" : {
            "text" : "Storing a plain text password in a configuration file could result in a system compromise.\n\n\n"
          },
          "help" : {
            "text" : "Storing a plain text password in a configuration file allows anyone who can read the file access to the password-protected resource. Developers sometimes believe that they cannot defend the application from someone who has access to the configuration, but this attitude makes an attacker's job easier. Good password management guidelines require that a password never be stored in plain text.\n\nA password should never be stored in plain text. An administrator should be required to enter the password when the system starts. If that approach is impractical, a less secure but often adequate solution is to obfuscate the password and scatter the de-obfuscation material around the system so that an attacker has to obtain and correctly combine multiple system resources to decipher the password.\n\nMicrosoft(R) provides a tool that can be used in conjunction with the Windows Data Protection application programming interface (DPAPI) to protect sensitive application entries in configuration files [1].\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8078/?engineType=SCA&issue=8F528F2065EF96CE3E7D79EDBE1D52D7"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8079",
          "shortDescription" : {
            "text" : "Password Management: Password in Configuration File"
          },
          "fullDescription" : {
            "text" : "Storing a plain text password in a configuration file could result in a system compromise.\n\n\n"
          },
          "help" : {
            "text" : "Storing a plain text password in a configuration file allows anyone who can read the file access to the password-protected resource. Developers sometimes believe that they cannot defend the application from someone who has access to the configuration, but this attitude makes an attacker's job easier. Good password management guidelines require that a password never be stored in plain text.\n\nA password should never be stored in plain text. An administrator should be required to enter the password when the system starts. If that approach is impractical, a less secure but often adequate solution is to obfuscate the password and scatter the de-obfuscation material around the system so that an attacker has to obtain and correctly combine multiple system resources to decipher the password.\n\nMicrosoft(R) provides a tool that can be used in conjunction with the Windows Data Protection application programming interface (DPAPI) to protect sensitive application entries in configuration files [1].\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8079/?engineType=SCA&issue=8F528F2065EF96CE3E7D79EDBE1D52D8"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "8080",
          "shortDescription" : {
            "text" : "Password Management: Password in Configuration File"
          },
          "fullDescription" : {
            "text" : "Storing a plain text password in a configuration file could result in a system compromise.\n\n\n"
          },
          "help" : {
            "text" : "Storing a plain text password in a configuration file allows anyone who can read the file access to the password-protected resource. Developers sometimes believe that they cannot defend the application from someone who has access to the configuration, but this attitude makes an attacker's job easier. Good password management guidelines require that a password never be stored in plain text.\n\nA password should never be stored in plain text. An administrator should be required to enter the password when the system starts. If that approach is impractical, a less secure but often adequate solution is to obfuscate the password and scatter the de-obfuscation material around the system so that an attacker has to obtain and correctly combine multiple system resources to decipher the password.\n\nMicrosoft(R) provides a tool that can be used in conjunction with the Windows Data Protection application programming interface (DPAPI) to protect sensitive application entries in configuration files [1].\n\n\n\n\nFor more information, see http://localhost:2210/ssc/html/ssc/version/9/fix/8080/?engineType=SCA&issue=8F528F2065EF96CE3E7D79EDBE1D52D9"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        } ]
      }
    },
    "results" : [ {
      "ruleId" : "8016",
      "message" : {
        "text" : "Hardcoded passwords can compromise system security in a way that is not easy to remedy.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "765A9EC55F4E0B007AE936CF5FA7005D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/-1713376481/addnewuser.aspx.cs"
          },
          "region" : {
            "startLine" : 17,
            "endLine" : 17,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "addnewuser.aspx.cs:17 - Field: passwordQuestion"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-1713376481/addnewuser.aspx.cs"
                },
                "region" : {
                  "startLine" : 17
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "addnewuser.aspx.cs:17 - Field: passwordQuestion"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-1713376481/addnewuser.aspx.cs"
                },
                "region" : {
                  "startLine" : 17
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8212",
      "message" : {
        "text" : "The method Page_Load() in addnewuser.aspx.cs mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "C7946A05F164FB0C48650D9A10DFDCD1"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/-1713376481/addnewuser.aspx.cs"
          },
          "region" : {
            "startLine" : 22,
            "endLine" : 22,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "addnewuser.aspx.cs:22 - Read OWASP.WebGoat.NET.AddNewUser.passwordQuestion"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-1713376481/addnewuser.aspx.cs"
                },
                "region" : {
                  "startLine" : 22
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "addnewuser.aspx.cs:22 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-1713376481/addnewuser.aspx.cs"
                },
                "region" : {
                  "startLine" : 22
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "addnewuser.aspx.cs:22 - Read OWASP.WebGoat.NET.AddNewUser.passwordQuestion"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-1713376481/addnewuser.aspx.cs"
                },
                "region" : {
                  "startLine" : 22
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "addnewuser.aspx.cs:22 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-1713376481/addnewuser.aspx.cs"
                },
                "region" : {
                  "startLine" : 22
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8267",
      "message" : {
        "text" : "The method Page_Load() in default.aspx.cs on line 29creates a cookie without the <code>secure</code> flag set to <code>true</code>.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "DD2CC28E2790954379C4B3A52240DC05"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/-1713376481/default.aspx.cs"
          },
          "region" : {
            "startLine" : 29,
            "endLine" : 29,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "default.aspx.cs:29 - Add(cookie)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-1713376481/default.aspx.cs"
                },
                "region" : {
                  "startLine" : 29
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "default.aspx.cs:21 - Branch taken: (this.du.TestConnection() == true)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-1713376481/default.aspx.cs"
                },
                "region" : {
                  "startLine" : 21
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "default.aspx.cs:28 - cookie = new HttpCookie(...)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-1713376481/default.aspx.cs"
                },
                "region" : {
                  "startLine" : 28
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "default.aspx.cs:29 - Add(cookie)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-1713376481/default.aspx.cs"
                },
                "region" : {
                  "startLine" : 29
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8228",
      "message" : {
        "text" : "The method btnReverse_Click() in proxysetup.aspx.cs sends unvalidated data to a web browser on line 17, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "CB9A7AE96C6472D4B07B83FFF6A30AFD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/-1713376481/proxysetup.aspx.cs"
          },
          "region" : {
            "startLine" : 17,
            "endLine" : 17,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "proxysetup.aspx.cs:15 - get_Text(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-1713376481/proxysetup.aspx.cs"
                },
                "region" : {
                  "startLine" : 15
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "proxysetup.aspx.cs:17 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-1713376481/proxysetup.aspx.cs"
                },
                "region" : {
                  "startLine" : 17
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "proxysetup.aspx.cs:15 - get_Text(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-1713376481/proxysetup.aspx.cs"
                },
                "region" : {
                  "startLine" : 15
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "proxysetup.aspx.cs:15 - Assignment to name"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-1713376481/proxysetup.aspx.cs"
                },
                "region" : {
                  "startLine" : 15
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "proxysetup.aspx.cs:17 - reverse(0 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-1713376481/proxysetup.aspx.cs"
                },
                "region" : {
                  "startLine" : 17
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "proxysetup.aspx.cs:17 - Concat(1 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-1713376481/proxysetup.aspx.cs"
                },
                "region" : {
                  "startLine" : 17
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "proxysetup.aspx.cs:17 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-1713376481/proxysetup.aspx.cs"
                },
                "region" : {
                  "startLine" : 17
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "7845",
      "message" : {
        "text" : "The function ProcessRequest() in autocomplete.ashx.cs accesses a variable in an ambiguous way at line 25, which can leave the program open to attack.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "38A66466156F0EB0331998A43A494035"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/-967081456/autocomplete.ashx.cs"
          },
          "region" : {
            "startLine" : 25,
            "endLine" : 25,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "autocomplete.ashx.cs:25 - get_Item()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/autocomplete.ashx.cs"
                },
                "region" : {
                  "startLine" : 25
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "autocomplete.ashx.cs:25 - get_Item()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/autocomplete.ashx.cs"
                },
                "region" : {
                  "startLine" : 25
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8313",
      "message" : {
        "text" : "The method ProcessRequest() in autocomplete.ashx.cs sends unvalidated data to a web browser on line 33, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "F374EA20FC310E7762297E5FFE4D7B65"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/-967081456/autocomplete.ashx.cs"
          },
          "region" : {
            "startLine" : 33,
            "endLine" : 33,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "autocomplete.ashx.cs:20 - URL - /autocomplete.ashx.cs"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/autocomplete.ashx.cs"
                },
                "region" : {
                  "startLine" : 20
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "autocomplete.ashx.cs:25 - get_Item(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/autocomplete.ashx.cs"
                },
                "region" : {
                  "startLine" : 25
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "autocomplete.ashx.cs:33 - Write(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/autocomplete.ashx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "autocomplete.ashx.cs:25 - get_Item(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/autocomplete.ashx.cs"
                },
                "region" : {
                  "startLine" : 25
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "autocomplete.ashx.cs:25 - Assignment to query"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/autocomplete.ashx.cs"
                },
                "region" : {
                  "startLine" : 25
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "autocomplete.ashx.cs:28 - ToJSONSAutocompleteString(0 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/autocomplete.ashx.cs"
                },
                "region" : {
                  "startLine" : 28
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "autocomplete.ashx.cs:28 - Assignment to json"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/autocomplete.ashx.cs"
                },
                "region" : {
                  "startLine" : 28
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "autocomplete.ashx.cs:33 - Write(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/autocomplete.ashx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "7902",
      "message" : {
        "text" : "The method ButtonLogOn_Click() in customerlogin.aspx.cs writes unvalidated user input to the log on line 36. An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "48F1D62602B44E56380F09336982B2A0"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
          },
          "region" : {
            "startLine" : 36,
            "endLine" : 36,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:34 - get_Text(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 34
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:36 - Info(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 36
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:34 - get_Text(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 34
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:34 - Assignment to pwd"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 34
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:36 - Concat(1 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 36
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:36 - Info(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 36
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "7936",
      "message" : {
        "text" : "The method ButtonLogOn_Click() in customerlogin.aspx.cs writes unvalidated user input to the log on line 36. An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "576C98CD06F4BCB300512F3FD89466E8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
          },
          "region" : {
            "startLine" : 36,
            "endLine" : 36,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:33 - get_Text(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:36 - Info(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 36
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:33 - get_Text(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:33 - Assignment to email"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:36 - Concat(1 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 36
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:36 - Concat(0 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 36
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:36 - Concat(0 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 36
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:36 - Info(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 36
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "7888",
      "message" : {
        "text" : "The method ButtonLogOn_Click() in customerlogin.aspx.cs on line 65creates a cookie without the <code>secure</code> flag set to <code>true</code>.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "45B5287CA14A1063A52C820B8C8E0829"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
          },
          "region" : {
            "startLine" : 65,
            "endLine" : 65,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:65 - Add(cookie)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 65
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:38 - Branch not taken: (this.du.IsValidCustomerLogin(email, pwd) == true)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 38
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:59 - cookie = new HttpCookie(...)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 59
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:65 - Add(cookie)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 65
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8284",
      "message" : {
        "text" : "The file customerlogin.aspx.cs passes unvalidated data to an HTTP redirect on line 72. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "E3ED55F907777B9A8403F632AEACC416"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
          },
          "region" : {
            "startLine" : 72,
            "endLine" : 72,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:67 - get_QueryString(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 67
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:72 - Redirect(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 72
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:67 - get_QueryString(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 67
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:67 - get_Item(this['ReturnUrl'] : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 67
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:67 - Assignment to returnUrl"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 67
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "customerlogin.aspx.cs:72 - Redirect(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/customerlogin.aspx.cs"
                },
                "region" : {
                  "startLine" : 72
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8151",
      "message" : {
        "text" : "The method ButtonCheckEmail_Click() in forgotpassword.aspx.cs on line 49creates a cookie without the <code>secure</code> flag set to <code>true</code>.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "B0F9B4482C54466AA26A214B09177364"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/-967081456/forgotpassword.aspx.cs"
          },
          "region" : {
            "startLine" : 49,
            "endLine" : 49,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:49 - Add(cookie)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 49
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:30 - Branch not taken: (IsNullOrEmpty((*result)[0]) != true)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 30
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:43 - cookie = new HttpCookie(...)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 43
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:49 - Add(cookie)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 49
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "7709",
      "message" : {
        "text" : "The method ButtonRecoverPassword_Click() in forgotpassword.aspx.cs mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "03BC7868161DEF7D124EBC88C1921287"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/-967081456/forgotpassword.aspx.cs"
          },
          "region" : {
            "startLine" : 67,
            "endLine" : 67,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:84 - Read password"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 84
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:67 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 67
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:84 - Read password"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 84
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:84 - Return password"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 84
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:67 - getPassword(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 67
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:67 - Concat(1 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 67
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:67 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 67
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8018",
      "message" : {
        "text" : "The function Page_Load() in orders.aspx.cs accesses a variable in an ambiguous way at line 62, which can leave the program open to attack.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "76D9ABB086936612CCC216B575F9BD65"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
          },
          "region" : {
            "startLine" : 62,
            "endLine" : 62,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "orders.aspx.cs:62 - get_Item()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
                },
                "region" : {
                  "startLine" : 62
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "orders.aspx.cs:62 - get_Item()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
                },
                "region" : {
                  "startLine" : 62
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8146",
      "message" : {
        "text" : "The method Page_Load() in orders.aspx.cs sends unvalidated data to a web browser on line 77, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "ADB3FC4234A79F01B0CDAFF8A305CCCB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
          },
          "region" : {
            "startLine" : 77,
            "endLine" : 77,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "orders.aspx.cs:77 - get_RawUrl(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
                },
                "region" : {
                  "startLine" : 77
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "orders.aspx.cs:77 - set_NavigateUrl(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
                },
                "region" : {
                  "startLine" : 77
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "orders.aspx.cs:77 - get_RawUrl(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
                },
                "region" : {
                  "startLine" : 77
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "orders.aspx.cs:77 - Concat(0 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
                },
                "region" : {
                  "startLine" : 77
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "orders.aspx.cs:77 - Concat(0 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
                },
                "region" : {
                  "startLine" : 77
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "orders.aspx.cs:77 - set_NavigateUrl(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
                },
                "region" : {
                  "startLine" : 77
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "7804",
      "message" : {
        "text" : "The method Page_Load() in orders.aspx.cs sends unvalidated data to a web browser on line 83, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "2C3E7E16EDD57F1174C139FC41B0E86F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
          },
          "region" : {
            "startLine" : 83,
            "endLine" : 83,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "orders.aspx.cs:62 - get_Item(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
                },
                "region" : {
                  "startLine" : 62
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "orders.aspx.cs:83 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
                },
                "region" : {
                  "startLine" : 83
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "orders.aspx.cs:62 - get_Item(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
                },
                "region" : {
                  "startLine" : 62
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "orders.aspx.cs:62 - Assignment to orderNumber"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
                },
                "region" : {
                  "startLine" : 62
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "orders.aspx.cs:83 - Concat(1 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
                },
                "region" : {
                  "startLine" : 83
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "orders.aspx.cs:83 - Concat(0 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
                },
                "region" : {
                  "startLine" : 83
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "orders.aspx.cs:83 - Concat(0 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
                },
                "region" : {
                  "startLine" : 83
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "orders.aspx.cs:83 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
                },
                "region" : {
                  "startLine" : 83
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8337",
      "message" : {
        "text" : "The function Page_Load() in orders.aspx.cs accesses a variable in an ambiguous way at line 88, which can leave the program open to attack.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "FC48340624DC5715BD6CA816799C7D75"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
          },
          "region" : {
            "startLine" : 88,
            "endLine" : 88,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "orders.aspx.cs:88 - get_Item()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
                },
                "region" : {
                  "startLine" : 88
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "orders.aspx.cs:88 - get_Item()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/orders.aspx.cs"
                },
                "region" : {
                  "startLine" : 88
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "7782",
      "message" : {
        "text" : "The function LoadComments() in productdetails.aspx.cs accesses a variable in an ambiguous way at line 55, which can leave the program open to attack.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "22C287B39C27FBCFAA7CC8CAD32D5129"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/-967081456/productdetails.aspx.cs"
          },
          "region" : {
            "startLine" : 55,
            "endLine" : 55,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "productdetails.aspx.cs:55 - get_Item()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/productdetails.aspx.cs"
                },
                "region" : {
                  "startLine" : 55
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "productdetails.aspx.cs:55 - get_Item()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/-967081456/productdetails.aspx.cs"
                },
                "region" : {
                  "startLine" : 55
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8231",
      "message" : {
        "text" : "The method MakeRow() in encryptvsencode.aspx.cs sends unvalidated data to a web browser on line 67, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "CC68CE1FC5C0BDD15408957BCC20B946"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
          },
          "region" : {
            "startLine" : 67,
            "endLine" : 67,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:38 - get_Text(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 38
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:67 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 67
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:38 - get_Text(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 38
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:38 - Assignment to secret"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 38
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:44 - CustomCryptoEncrypt(0 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 44
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:44 - MakeRow(1)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 44
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:67 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 67
                }
              }
            }
          } ]
        }, {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:38 - get_Text(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 38
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:67 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 67
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:38 - get_Text(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 38
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:38 - Assignment to secret"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 38
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:46 - Base64(0 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 46
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:46 - MakeRow(1)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 46
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:67 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 67
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8021",
      "message" : {
        "text" : "The method SHA() in encryptvsencode.aspx.cs can dereference a null-pointer on line 108, thereby raising a <code>NullException</code>.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "78E1DB3CBE184FE3528B2869DA7BFB0B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
          },
          "region" : {
            "startLine" : 108,
            "endLine" : 108,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:108 - sha.ComputeHash(...) : sha is not checked for null value before being dereferenced"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 108
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:97 - sha = null : sha is declared and/or assigned to null value"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 97
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:101 - Branch not taken: (hash != Sha1)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 101
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:104 - Branch not taken: (hash != Sha256)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 104
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:99 - goto"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 99
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "encryptvsencode.aspx.cs:108 - sha.ComputeHash(...) : sha is not checked for null value before being dereferenced"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/encryptvsencode.aspx.cs"
                },
                "region" : {
                  "startLine" : 108
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8005",
      "message" : {
        "text" : "The method ButtonCheckEmail_Click() in forgotpassword.aspx.cs on line 48creates a cookie without the <code>secure</code> flag set to <code>true</code>.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "7005BEEC3A9F43E967589CC0D391B35F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/1894963386/forgotpassword.aspx.cs"
          },
          "region" : {
            "startLine" : 48,
            "endLine" : 48,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:48 - Add(cookie)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 48
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:29 - Branch not taken: (IsNullOrEmpty((*result)[0]) != true)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 29
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:42 - cookie = new HttpCookie(...)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 42
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:48 - Add(cookie)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 48
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8279",
      "message" : {
        "text" : "The method ButtonRecoverPassword_Click() in forgotpassword.aspx.cs mishandles confidential information, which can compromise user privacy and is often illegal.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "E103525EE8E39CD7A66FF4AABB038C09"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/1894963386/forgotpassword.aspx.cs"
          },
          "region" : {
            "startLine" : 66,
            "endLine" : 66,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:78 - Read password"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 78
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:66 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 66
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:78 - Read password"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 78
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:78 - Return password"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 78
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:66 - getPassword(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 66
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:66 - Concat(1 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 66
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "forgotpassword.aspx.cs:66 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/forgotpassword.aspx.cs"
                },
                "region" : {
                  "startLine" : 66
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8271",
      "message" : {
        "text" : "The method Page_Load() in headerinjection.aspx.cs includes unvalidated data in an HTTP cookie on line 19. This enables cookie manipulation attacks and can lead to other HTTP Response header manipulation attacks like: cache-poisoning, cross-site scripting, cross-user defacement, page hijacking or open redirect.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "DE85E5D1A941B7C96062AD851EE10748"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/1894963386/headerinjection.aspx.cs"
          },
          "region" : {
            "startLine" : 19,
            "endLine" : 19,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "headerinjection.aspx.cs:19 - get_QueryString(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/headerinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 19
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "headerinjection.aspx.cs:19 - set_Value(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/headerinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 19
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "headerinjection.aspx.cs:19 - get_QueryString(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/headerinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 19
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "headerinjection.aspx.cs:19 - get_Item(this['Cookie'] : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/headerinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 19
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "headerinjection.aspx.cs:19 - set_Value(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/headerinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 19
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8003",
      "message" : {
        "text" : "The method Page_Load() in headerinjection.aspx.cs on line 21creates a cookie without the <code>secure</code> flag set to <code>true</code>.\n\n\n"
      },
      "level" : "note",
      "partialFingerprints" : {
        "issueInstanceId" : "6F90F18FAE59EF763331DFEE7C16AA47"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/1894963386/headerinjection.aspx.cs"
          },
          "region" : {
            "startLine" : 21,
            "endLine" : 21,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "headerinjection.aspx.cs:21 - Add(cookie)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/headerinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 21
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "headerinjection.aspx.cs:16 - Branch taken: (this.get_Request().get_QueryString().get_Item(\"Cookie\") != null)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/headerinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 16
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "headerinjection.aspx.cs:18 - cookie = new HttpCookie(...)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/headerinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 18
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "headerinjection.aspx.cs:21 - Add(cookie)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/headerinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 21
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8225",
      "message" : {
        "text" : "The method Page_Load() in headerinjection.aspx.cs sends unvalidated data to a web browser on line 33, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "CAD3231725190CC6A1881ED98346C672"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/1894963386/headerinjection.aspx.cs"
          },
          "region" : {
            "startLine" : 33,
            "endLine" : 33,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "headerinjection.aspx.cs:33 - get_Headers(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/headerinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "headerinjection.aspx.cs:33 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/headerinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "headerinjection.aspx.cs:33 - get_Headers(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/headerinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "headerinjection.aspx.cs:33 - ToString(this : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/headerinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "headerinjection.aspx.cs:33 - Replace(this : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/headerinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "headerinjection.aspx.cs:33 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/headerinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "7792",
      "message" : {
        "text" : "The method btnDigest_Click() in messagedigest.aspx.cs writes unvalidated user input to the log on line 25. An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "27BDE6D1B9ED1376DFEDA5F43FAB4B30"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/1894963386/messagedigest.aspx.cs"
          },
          "region" : {
            "startLine" : 25,
            "endLine" : 25,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "messagedigest.aspx.cs:25 - get_Text(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/messagedigest.aspx.cs"
                },
                "region" : {
                  "startLine" : 25
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "messagedigest.aspx.cs:25 - Info(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/messagedigest.aspx.cs"
                },
                "region" : {
                  "startLine" : 25
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "messagedigest.aspx.cs:25 - get_Text(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/messagedigest.aspx.cs"
                },
                "region" : {
                  "startLine" : 25
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "messagedigest.aspx.cs:25 - Format(1 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/messagedigest.aspx.cs"
                },
                "region" : {
                  "startLine" : 25
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "messagedigest.aspx.cs:25 - Info(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/messagedigest.aspx.cs"
                },
                "region" : {
                  "startLine" : 25
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "7934",
      "message" : {
        "text" : "Attackers can control the file system path argument to MapPath() at pathmanipulation.aspx.cs line 38, which allows them to access or modify otherwise protected files.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "5622923F2D3DC1279171A713867CD0C2"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
          },
          "region" : {
            "startLine" : 38,
            "endLine" : 38,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:33 - get_QueryString(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:38 - MapPath(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 38
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:33 - get_QueryString(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:33 - get_Item(this['filename'] : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:33 - Assignment to filename"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:38 - Concat(1 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 38
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:38 - MapPath(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 38
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8072",
      "message" : {
        "text" : "The method Page_Load() in pathmanipulation.aspx.cs sends unvalidated data to a web browser on line 43, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "8C19B7FF6FC7DB38E9FE9650BAB31B27"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
          },
          "region" : {
            "startLine" : 43,
            "endLine" : 43,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:33 - get_QueryString(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:43 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 43
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:33 - get_QueryString(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:33 - get_Item(this['filename'] : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:33 - Assignment to filename"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:43 - Concat(1 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 43
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:43 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 43
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8173",
      "message" : {
        "text" : "The method ResponseFile() in pathmanipulation.aspx.cs includes unvalidated data in an HTTP response header on line 79. This enables attacks such as cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "B8A11F63D5F15A4FF9787AC89AC012B8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
          },
          "region" : {
            "startLine" : 79,
            "endLine" : 79,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:33 - get_QueryString(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:79 - AddHeader(1)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 79
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:33 - get_QueryString(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:33 - get_Item(this['filename'] : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:33 - Assignment to filename"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 33
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:38 - ResponseFile(2)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 38
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:79 - UrlEncode(0 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 79
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:79 - Concat(1 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 79
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "pathmanipulation.aspx.cs:79 - AddHeader(1)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/pathmanipulation.aspx.cs"
                },
                "region" : {
                  "startLine" : 79
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8132",
      "message" : {
        "text" : "The method Reset() in random.aspx.cs stores a non-serializable object as an <code>HttpSessionState</code> attribute on line 65, which can damage application reliability.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "A731707370CC356514C46E02F21C759B"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/1894963386/random.aspx.cs"
          },
          "region" : {
            "startLine" : 65,
            "endLine" : 65,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "random.aspx.cs:65 - FunctionCall: set_Item"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/random.aspx.cs"
                },
                "region" : {
                  "startLine" : 65
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "random.aspx.cs:65 - FunctionCall: set_Item"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/random.aspx.cs"
                },
                "region" : {
                  "startLine" : 65
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8299",
      "message" : {
        "text" : "The function Page_Load() in reflectedxss.aspx.cs accesses a variable in an ambiguous way at line 19, which can leave the program open to attack.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "EA6B8E0CED9F959039B586044075FC75"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/1894963386/reflectedxss.aspx.cs"
          },
          "region" : {
            "startLine" : 19,
            "endLine" : 19,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "reflectedxss.aspx.cs:19 - get_Item()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/reflectedxss.aspx.cs"
                },
                "region" : {
                  "startLine" : 19
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "reflectedxss.aspx.cs:19 - get_Item()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/reflectedxss.aspx.cs"
                },
                "region" : {
                  "startLine" : 19
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8298",
      "message" : {
        "text" : "The function Page_Load() in reflectedxss.aspx.cs accesses a variable in an ambiguous way at line 20, which can leave the program open to attack.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "EA6B8E0CED9F959039B586044075FC74"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/1894963386/reflectedxss.aspx.cs"
          },
          "region" : {
            "startLine" : 20,
            "endLine" : 20,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "reflectedxss.aspx.cs:20 - get_Item()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/reflectedxss.aspx.cs"
                },
                "region" : {
                  "startLine" : 20
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "reflectedxss.aspx.cs:20 - get_Item()"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/reflectedxss.aspx.cs"
                },
                "region" : {
                  "startLine" : 20
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8281",
      "message" : {
        "text" : "The method LoadCity() in reflectedxss.aspx.cs sends unvalidated data to a web browser on line 26, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "E31C362F7F402CEAECC7194F2724EC8E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/1894963386/reflectedxss.aspx.cs"
          },
          "region" : {
            "startLine" : 26,
            "endLine" : 26,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "reflectedxss.aspx.cs:20 - get_Item(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/reflectedxss.aspx.cs"
                },
                "region" : {
                  "startLine" : 20
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "reflectedxss.aspx.cs:26 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/reflectedxss.aspx.cs"
                },
                "region" : {
                  "startLine" : 26
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "reflectedxss.aspx.cs:20 - get_Item(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/reflectedxss.aspx.cs"
                },
                "region" : {
                  "startLine" : 20
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "reflectedxss.aspx.cs:20 - LoadCity(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/reflectedxss.aspx.cs"
                },
                "region" : {
                  "startLine" : 20
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "reflectedxss.aspx.cs:26 - Concat(1 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/reflectedxss.aspx.cs"
                },
                "region" : {
                  "startLine" : 26
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "reflectedxss.aspx.cs:26 - Concat(0 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/reflectedxss.aspx.cs"
                },
                "region" : {
                  "startLine" : 26
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "reflectedxss.aspx.cs:26 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/reflectedxss.aspx.cs"
                },
                "region" : {
                  "startLine" : 26
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8314",
      "message" : {
        "text" : "Untrusted data is passed to the application and used as a regular expression. This can cause the thread to overconsume CPU resources.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "F390DDB21A93A0C2A4913E57CC449DAD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/1894963386/regexdos.aspx.cs"
          },
          "region" : {
            "startLine" : 23,
            "endLine" : 23,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "regexdos.aspx.cs:20 - get_Text(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/regexdos.aspx.cs"
                },
                "region" : {
                  "startLine" : 20
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "regexdos.aspx.cs:23 - Regex(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/regexdos.aspx.cs"
                },
                "region" : {
                  "startLine" : 23
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "regexdos.aspx.cs:20 - get_Text(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/regexdos.aspx.cs"
                },
                "region" : {
                  "startLine" : 20
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "regexdos.aspx.cs:20 - Assignment to userName"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/regexdos.aspx.cs"
                },
                "region" : {
                  "startLine" : 20
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "regexdos.aspx.cs:23 - Regex(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/regexdos.aspx.cs"
                },
                "region" : {
                  "startLine" : 23
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "7945",
      "message" : {
        "text" : "The method Page_Load() in verbtampering.aspx.cs sends unvalidated data to a web browser on line 15, which can result in the browser executing malicious code.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "595C66E5636600D50B491FA86A0CFED1"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/1894963386/verbtampering.aspx.cs"
          },
          "region" : {
            "startLine" : 15,
            "endLine" : 15,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "verbtamperingattack.aspx.cs:14 - get_QueryString(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/verbtamperingattack.aspx.cs"
                },
                "region" : {
                  "startLine" : 14
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "verbtampering.aspx.cs:15 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/verbtampering.aspx.cs"
                },
                "region" : {
                  "startLine" : 15
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "verbtamperingattack.aspx.cs:14 - get_QueryString(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/verbtamperingattack.aspx.cs"
                },
                "region" : {
                  "startLine" : 14
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "verbtamperingattack.aspx.cs:14 - get_Item(this['message'] : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/verbtamperingattack.aspx.cs"
                },
                "region" : {
                  "startLine" : 14
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "verbtamperingattack.aspx.cs:14 - Assignment to OWASP.WebGoat.NET.VerbTampering.tamperedMessage"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/verbtamperingattack.aspx.cs"
                },
                "region" : {
                  "startLine" : 14
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "verbtampering.aspx.cs:15 - Read OWASP.WebGoat.NET.VerbTampering.tamperedMessage"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/verbtampering.aspx.cs"
                },
                "region" : {
                  "startLine" : 15
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "verbtampering.aspx.cs:15 - set_Text(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/verbtampering.aspx.cs"
                },
                "region" : {
                  "startLine" : 15
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8350",
      "message" : {
        "text" : "On line 28 of xpathinjection.aspx.cs, the method FindSalesPerson() invokes an XPath query built using unvalidated input. This call could allow an attacker to modify the statement's meaning or to execute arbitrary XPath queries.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "FF9040486E29A08396CE69941B06E8D8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Libs/dotnet/1894963386/xpathinjection.aspx.cs"
          },
          "region" : {
            "startLine" : 28,
            "endLine" : 28,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "xpathinjection.aspx.cs:20 - get_QueryString(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/xpathinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 20
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "xpathinjection.aspx.cs:28 - SelectNodes(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/xpathinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 28
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "xpathinjection.aspx.cs:20 - get_QueryString(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/xpathinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 20
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "xpathinjection.aspx.cs:20 - get_Item(this['state'] : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/xpathinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 20
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "xpathinjection.aspx.cs:20 - FindSalesPerson(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/xpathinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 20
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "xpathinjection.aspx.cs:28 - Concat(1 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/xpathinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 28
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "xpathinjection.aspx.cs:28 - Concat(0 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/xpathinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 28
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "xpathinjection.aspx.cs:28 - SelectNodes(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/xpathinjection.aspx.cs"
                },
                "region" : {
                  "startLine" : 28
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8046",
      "message" : {
        "text" : "Hardcoded passwords can compromise system security in a way that is not easy to remedy.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "8300BCE32737B84CC6762AC07491A5F4"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Src/WebGoat/App_Code/DB/DbConstants.cs"
          },
          "region" : {
            "startLine" : 16,
            "endLine" : 16,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "DbConstants.cs:16 - Field: KEY_PWD"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Src/WebGoat/App_Code/DB/DbConstants.cs"
                },
                "region" : {
                  "startLine" : 16
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "DbConstants.cs:16 - Field: KEY_PWD"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Src/WebGoat/App_Code/DB/DbConstants.cs"
                },
                "region" : {
                  "startLine" : 16
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8204",
      "message" : {
        "text" : "The method GenerateWeakDigest() in WeakMessageDigest.cs writes unvalidated user input to the log on line 26. An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "C59F2FA4B9CC20EC5AF35B4C642D8D8C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Src/WebGoat/App_Code/WeakMessageDigest.cs"
          },
          "region" : {
            "startLine" : 26,
            "endLine" : 26,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "messagedigest.aspx.cs:23 - get_Text(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/messagedigest.aspx.cs"
                },
                "region" : {
                  "startLine" : 23
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "WeakMessageDigest.cs:26 - Debug(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Src/WebGoat/App_Code/WeakMessageDigest.cs"
                },
                "region" : {
                  "startLine" : 26
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "messagedigest.aspx.cs:23 - get_Text(return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/messagedigest.aspx.cs"
                },
                "region" : {
                  "startLine" : 23
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "messagedigest.aspx.cs:23 - GenerateWeakDigest(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Libs/dotnet/1894963386/messagedigest.aspx.cs"
                },
                "region" : {
                  "startLine" : 23
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "WeakMessageDigest.cs:26 - Format(1 : return)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Src/WebGoat/App_Code/WeakMessageDigest.cs"
                },
                "region" : {
                  "startLine" : 26
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "WeakMessageDigest.cs:26 - Debug(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Src/WebGoat/App_Code/WeakMessageDigest.cs"
                },
                "region" : {
                  "startLine" : 26
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "7989",
      "message" : {
        "text" : "The application session cookie is created without the <code>secure</code> flag set to <code>true</code>.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "6AB1F075ED1868B976DF091E3E05D60E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Src/WebGoat/Web.config"
          },
          "region" : {
            "startLine" : 56,
            "endLine" : 56,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Web.config:56"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Src/WebGoat/Web.config"
                },
                "region" : {
                  "startLine" : 56
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Web.config:56"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Src/WebGoat/Web.config"
                },
                "region" : {
                  "startLine" : 56
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8078",
      "message" : {
        "text" : "Storing a plain text password in a configuration file could result in a system compromise.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "8F528F2065EF96CE3E7D79EDBE1D52D7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Src/WebGoat/Web.config"
          },
          "region" : {
            "startLine" : 58,
            "endLine" : 58,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Web.config:58"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Src/WebGoat/Web.config"
                },
                "region" : {
                  "startLine" : 58
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Web.config:58"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Src/WebGoat/Web.config"
                },
                "region" : {
                  "startLine" : 58
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8079",
      "message" : {
        "text" : "Storing a plain text password in a configuration file could result in a system compromise.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "8F528F2065EF96CE3E7D79EDBE1D52D8"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Src/WebGoat/Web.config"
          },
          "region" : {
            "startLine" : 59,
            "endLine" : 59,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Web.config:59"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Src/WebGoat/Web.config"
                },
                "region" : {
                  "startLine" : 59
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Web.config:59"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Src/WebGoat/Web.config"
                },
                "region" : {
                  "startLine" : 59
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "8080",
      "message" : {
        "text" : "Storing a plain text password in a configuration file could result in a system compromise.\n\n\n"
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "8F528F2065EF96CE3E7D79EDBE1D52D9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "Src/WebGoat/Web.config"
          },
          "region" : {
            "startLine" : 60,
            "endLine" : 60,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "Web.config:60"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Src/WebGoat/Web.config"
                },
                "region" : {
                  "startLine" : 60
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "Web.config:60"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "Src/WebGoat/Web.config"
                },
                "region" : {
                  "startLine" : 60
                }
              }
            }
          } ]
        } ]
      } ]
    } ]
  } ]
}